	.alias os_version  $0101
	.alias dos_version $0101
	.alias constant_partition_type_fat32_chs $0b
	.alias constant_partition_type_fat32_lba $0c

	; DOS error codes
	.alias dos_errorcode_no_such_disk $80
	.alias dos_errorcode_name_too_long $81
	.alias dos_errorcode_not_implemented $82
	.alias dos_errorcode_file_too_long $83
	.alias dos_errorcode_too_many_open_files $84
	.alias dos_errorcode_invalid_cluster $85

dos_and_process_trap:
	; Sub-function is selected by X.
	; Bits 6-1 are the only ones used.
	; Mask out bit 0 so that indirect jmp's are valid.
	txa
	and #$FE
	; to save memory we only allow this table to be 128 bytes long,
	; thus we have to check that bit 7 is clear.
	bmi invalid_subfunction
	tax
	jmp (dos_and_process_trap_table,x)
dos_and_process_trap_table:
	; $00 - $0E
	.word trap_dos_getversion
	.word trap_dos_getdefaultdrive
	.word trap_dos_selectdrive
	.word trap_dos_getdisksize
	.word trap_dos_getcwd
	.word trap_dos_chdir
	.word trap_dos_mkdir
	.word trap_dos_rmdir
	; $10 - $1E
	.word trap_dos_opendir
	.word trap_dos_readdir
	.word trap_dos_closedir
	.word trap_dos_mkfile
	.word trap_dos_openfile
	.word trap_dos_closefile
	.word trap_dos_readfile
	.word trap_dos_writefile
	; $20 - $2E
	.word trap_dos_seekfile
	.word trap_dos_rmfile
	.word trap_dos_fstat
	.word trap_dos_rename
	.word trap_dos_filedate
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $30 - $3E
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $40 - $4E
	.word trap_dos_d81attach
	.word trap_dos_d81detach
	.word trap_dos_d81writeen
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $50 - $5E
	.word trap_dos_gettasklist
	.word trap_dos_sendmessage
	.word trap_dos_receivemessage
	.word trap_dos_writeintotask
	.word trap_dos_readoutoftask
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $70 - $7E
	.word trap_dos_terminateothertask
	.word trap_dos_create_task_native
	.word trap_dos_load_into_task
	.word trap_dos_create_task_c64
	.word trap_dos_create_task_c65
	.word trap_dos_exit_and_switch_to_task
	.word trap_dos_switch_to_task
	.word trap_dos_exit_task

; Return OS and DOS version.
; A/X = OS Version major/minor
; Z/Y = DOS Version major/minor
trap_dos_getversion:
	lda #<os_version
	sta hypervisor_x
	lda #>os_version
	sta hypervisor_a
	lda #<dos_version
	sta hypervisor_z
	lda #>dos_version
	sta hypervisor_y
	jmp return_from_trap_with_success

trap_dos_getdefaultdrive:
trap_dos_selectdrive:
trap_dos_getdisksize:
trap_dos_getcwd:
trap_dos_chdir:
trap_dos_mkdir:
trap_dos_rmdir:
trap_dos_opendir:
trap_dos_readdir:
trap_dos_closedir:
trap_dos_mkfile:
trap_dos_openfile:
trap_dos_closefile:
trap_dos_readfile:
trap_dos_writefile:
trap_dos_seekfile:
trap_dos_rmfile:
trap_dos_fstat:
trap_dos_rename:
trap_dos_filedate:
trap_dos_d81attach:
trap_dos_d81detach:
trap_dos_d81writeen:
trap_dos_gettasklist:
trap_dos_sendmessage:
trap_dos_receivemessage:
trap_dos_writeintotask:
trap_dos_readoutoftask:
trap_dos_terminateothertask:
trap_dos_create_task_native:
trap_dos_load_into_task:
trap_dos_create_task_c64:
trap_dos_create_task_c65:
trap_dos_exit_and_switch_to_task:
trap_dos_switch_to_task:
trap_dos_exit_task:
	jmp invalid_subfunction;



; Clear all file descriptors.
; This just consists of setting the drive number to $ff,
; which indicates "no such drive"
; Drive number field is first byte of file descriptor for convenience
dos_clear_filedescriptors:
	lda #$ff
	sta currenttask_filedescriptor0
	sta currenttask_filedescriptor1
	sta currenttask_filedescriptor2
	sta currenttask_filedescriptor3
	rts

; Read partition table from SD card.
; Add all FAT32 partitions to our list of known disks.
; This routine assumes that the SD card has been reset and is ready to
; service requests.
; XXX - We don't support extended partition tables! Only the old-fashion
; 4 DOS partitions.  We might get excited and add support for them later,
; but 
dos_read_partitiontable:

	; clear error code
	lda #0
	sta dos_error_code

	; Clear the list of known disks
	jsr dos_initialise_disklist

	jsr dos_read_mbr
	bcc drpt_fail

	; Make the sector buffer visible
	jsr sd_map_sectorbuffer

	; check for $55AA MBR signature
	lda [sd_sectorbuffer+$1FE]
	cmp #$55
	bne drpt_fail
	lda [sd_sectorbuffer+$1FF]
	cmp #$AA
	bne drpt_fail

	; Partitions start at offsets $1BE, $1CE, $1DE, $1EE
	; so consider each in turn.  Opening the partition causes other sectors to
	; be read, so we must re-read the MBR between each

	; get pointer to second half of sector buffer so that we can access the
	; partition entries as we see fit.
	lda #<[sd_sectorbuffer+$1BE]
	sta dos_scratch_vector
	lda #>[sd_sectorbuffer+$1BE]
	sta dos_scratch_vector+1
	jsr dos_consider_partition_entry
	
	jsr dos_read_mbr
	bcc drpt_fail
	lda #<[sd_sectorbuffer+$1CE]
	sta dos_scratch_vector
	jsr dos_consider_partition_entry

	jsr dos_read_mbr
	bcc drpt_fail
	lda #<[sd_sectorbuffer+$1DE]
	sta dos_scratch_vector
	jsr dos_consider_partition_entry

	jsr dos_read_mbr
	bcc drpt_fail
	lda #<[sd_sectorbuffer+$1EE]
	sta dos_scratch_vector
	jsr dos_consider_partition_entry

	rts

dos_read_mbr:
	; Offset zero  on disk
	lda #0
	sta sd_address_byte0
	sta sd_address_byte1
	sta sd_address_byte2
	sta sd_address_byte3

	; Read sector
	jsr sd_readsector
	bcc drpt_fail
	rts

dos_initialise_disklist:
	lda #0
	sta dos_disk_count
	rts

dos_consider_partition_entry:

	lda #$00
	sta dos_error_code

	; Offset within partition table entry of partition type
	ldy #$04
	; Get partition type byte
	lda (<dos_scratch_vector),y

	; We like FAT32 partitions, whether LBA or CHS addressed, although we actually
	; use LBA addressing.  XXX - Can this cause problems for CHS partitions?
	; (SD cards which must really use LBA, can still show up with CHS partitions!
	;  this is really annoying.)
	cmp #constant_partition_type_fat32_lba
	beq partitionisinteresting
	cmp #constant_partition_type_fat32_chs
	beq partitionisinteresting
	lda #$0f
	sta dos_error_code
	jmp partitionisnotinteresting

partitionisinteresting:
	lda #$01
	sta dos_error_code

	; Partition is FAT32, so add it to the list

	; Disk structures in dos_disk_table are 32 bytes long, so shift count left
	; 5 times to get offset in dos disk list table
	lda dos_disk_count
	asl
	asl
	asl
	asl
	asl
	tax

	; Copy relevant fields into place
	; These are start of partition and length of partition (both in sectors)
	; XXX - This requires that our dos_disk_table has these two fields together
	; at the start of the structure.
	ldy #$08
dcpe1:	lda (<dos_scratch_vector),y
	sta dos_disk_table,x
	inx
	iny
	cpy #$10
	bne dcpe1

	; Examine the internals of the partition to get the remaining fields.
	; At this point we no longer use the contents of the MBR
	lda #$02
	sta dos_error_code
	lda dos_disk_count
	jsr dos_disk_openpartition
	bcc partitionerror

	; Check if partition is bootable (or the only partition)
	; If so, make the partition the default disk
	lda dos_disk_count
	beq makethispartitionthedefault
	ldy #$00
	lda (<dos_scratch_vector),y
	bpl dontmakethispartitionthedefault
makethispartitionthedefault:
	lda dos_disk_count
	sta dos_default_disk
dontmakethispartitionthedefault:

partitionisnotinteresting:
	; return OK
	sec
	rts

drpt_fail:
	
partitionerror:
	; return ERROR
	clc
	rts

; Examine a partition to see if we can mount it.
; This routine fills in the missing fields for the disk entry as required.
; It assumes that fs_start_sector and fs_sector_count have been correctly set.
; Each disk entry consists of;
; Offset $00 - starting sector (4 bytes)
  	 .alias fs_start_sector $00
; Offset $04 - sector count (4 bytes)
  	 .alias fs_sector_count $04
; Offset $08 - Filesystem type & media source ($0x = FAT32, $xF = SD card, others reserved for now)
  	 .alias fs_type_and_source $08
; Remaining bytes are filesystem dependent:
; For FAT32:
; Offset $09 - length of fat (4 bytes) (FAT starts at fs_fat32_system_sectors)
  	 .alias fs_fat32_length_of_fat $09
; Offset $0D - system sectors (2 bytes)
  	 .alias fs_fat32_system_sectors $0D
; Offset $0F - reserved clusters (1 byte)
  	 .alias fs_fat32_reserved_clusters $0F
; Offset $10 - root dir cluster (2 bytes) 
  	 .alias fs_fat32_root_dir_cluster $10
; Offset $12 - cluster count (4 bytes)
  	 .alias fs_fat32_cluster_count $12
; Offset $16 - sectors per cluster
  	 .alias fs_fat32_sectors_per_cluster $16
; Offset $17 - copies of FAT
  	 .alias fs_fat32_fat_copies $17
; Offset $18 - first sector of cluster zero (4 bytes)
  	 .alias fs_fat32_cluster0_sector $18
; Offset $1C - Four spare bytes.
dos_disk_openpartition:
	; A contains the disk number we are trying to open.
	lda #$00
	sta dos_error_code

	; Load first sector of file system and parse.
	; This is the Volume Boot Record

	; Get offset of disk entry in our disk table structure 
	asl
	asl
	asl
	asl
	asl
	sta dos_disk_table_offset

	; Now pull the start sector from the structure and get ready to request
	; that structure from the SD card.
	ora #fs_start_sector
	tay
	ldx #$00
ddop1:	lda dos_disk_table,y
	sta sd_address_byte0,x
	iny
	inx
	cpx #$04
	bne ddop1
	; Convert sector number to byte offset for non-HC SD cards
	jsr sd_fix_sectornumber
	lda #$03
	sta dos_error_code
	jsr sd_readsector
	bcc partitionerror

	; We now have the sector, so parse.

	jsr sd_map_sectorbuffer

	; Check for 55/AA singature
	lda #$04
	sta dos_error_code
	lda [sd_sectorbuffer+$1FE]
	cmp #$55
	bne partitionerror
	lda [sd_sectorbuffer+$1FF]	
	cmp #$AA
	bne partitionerror

	; Start populating fields

	; Filter out obviously FAT16/FAT12 file systems
	lda #$05
	sta dos_error_code
	lda [sd_sectorbuffer+$11]
	bne partitionerror

	; get # copies of fat
	lda dos_disk_table_offset
	ora #fs_fat32_fat_copies
	tay
	lda [sd_sectorbuffer+$10]
	sta dos_disk_table,y

	; With root directory entries = 0, the reserved sector count
	; is the number of reserved sectors, plus (copies of fat) *
	; (sectors in one copy of the fat).
	; the first FAT begins immediately after the reserved sectors

	; Determine system sector count
	; (= reserved sectors + fat_count * fat_sectors)
	; $20 + $EE5 + $EE5 = $1DEA
	; plus partition offset = $81 = $1E6B
	; partition length = $3BAF7F
	; $08 sectors / cluster
	; so data sectors in partition = $3BAF7F - $1DEA = $3B9195
	; = $77232 clusters
	
	; Reserved sector field on disk is only 2 bytes!
	lda dos_disk_table_offset
	ora #fs_fat32_system_sectors	
	tay
	ldx #$00
ddop10:	lda [sd_sectorbuffer+$0E],x
	sta dos_disk_table,y
	iny
	inx
	cpx #$02
	bne ddop10

	; Store length of one copy of the FAT
	lda dos_disk_table_offset
	ora #fs_fat32_length_of_fat
	tay
	ldx #$00
ddop11:	lda [sd_sectorbuffer+$24],x
	sta dos_disk_table,y
	iny
	inx
	cpx #$04
	bne ddop11

	; Get number of reserved clusters.  We only allow upto 255 reserved
	; clusters, so report an error if the upper two bytes are not both zero
	lda #$06
	sta dos_error_code
	lda [sd_sectorbuffer+$2C+1]
	ora [sd_sectorbuffer+$2C+2]
	ora [sd_sectorbuffer+$2C+3]
	; XXX - 16 bit BNE should be fine here!
	;	bne partitionerror
	beq ddop11ok
	jmp partitionerror
ddop11ok:
	; <64K reserved clusters, so file system passes this test -- just copy number
	ldy dos_disk_table_offset
	lda [sd_sectorbuffer+$2C]
	sta [dos_disk_table+fs_fat32_reserved_clusters],y

	; Now work out the sector of cluster 0, by adding the length of
	; each FAT to fs_fat32_system_sectors to start of partition.
	; For efficiency, we pull the fields we need out of the sector buffer,
	; instead of working out their offsets in the disk entry structure.

	; Start with fs_fat32_system_sectors (which is 16 bits)
	lda dos_disk_table_offset
	ora #fs_fat32_system_sectors
	tay	
	lda dos_disk_table_offset
	ora #fs_fat32_cluster0_sector
	tax
	ldz #$02
ddop2:	lda dos_disk_table,y
	sta dos_disk_table,x
	iny
	inx
	dez
	bne ddop2
	; clear top 16 bits of cluster0_sector
	tza
	sta [dos_disk_table+0],x
	sta [dos_disk_table+1],x
	
	; Now add length of fat for each copy of the fat
	lda #$07
	sta dos_error_code
	ldz [sd_sectorbuffer+$10]     ; # of FAT copies
	beq partitionerror ; There must be at least one copy of the FAT!
ddop_addnextfatsectors:
	lda dos_disk_table_offset
	ora #fs_fat32_cluster0_sector
	tay
	ldx #$00
	clc
	php
ddop12:	plp
	lda dos_disk_table,y           ; cluster0_sector
	adc [sd_sectorbuffer+$24],x    ; sectors per fat
	sta dos_disk_table,y           ; cluster0_sector
	php
	iny
	inx
	cpx #$04
	bne ddop12
	plp
	dez
	bne ddop_addnextfatsectors

	; Next, we temporarily need the number of data sectors, so that we can work
	; out the number of clusters in the file system.
	; This is the total number of sectors in the partition, minus the number of
	; reserved sectors.

	; Subtract (cluster 0 sector = 32 bits) from
	; (length of filesystem in sectors = 32 bits)

	lda dos_disk_table_offset
	ora #fs_fat32_cluster0_sector
	tax
	lda dos_disk_table_offset
	ora #fs_fat32_cluster_count
	tay
	sec
	lda [sd_sectorbuffer+$20+0]
	sbc [dos_disk_table+0],x
	sta [dos_disk_table+0],y
	lda [sd_sectorbuffer+$20+1]
	sbc [dos_disk_table+1],x
	sta [dos_disk_table+1],y
	lda [sd_sectorbuffer+$20+2]
	sbc [dos_disk_table+2],x
	sta [dos_disk_table+2],y
	lda [sd_sectorbuffer+$20+3]
	sbc [dos_disk_table+3],x
	sta [dos_disk_table+3],y
	

	; Get sectors per cluster (and store in dos_disk_table entry)
	; (this gets destoryed below, so we have to re-read it again after) 
	lda dos_disk_table_offset
	ora #fs_fat32_sectors_per_cluster
	tay
	lda [sd_sectorbuffer+$0D]
	sta dos_disk_table,y

	; Now divide number of sectors available for clusters by the number of
	; sectors per cluster to obtain the number of actual clusters in the file
	; system.  Since clusters must contain a power-of-two number of sectors,
	; we can implement the division using a simple shift.

	; copy number of sectors into number of sectors ready for shifting down
	

	; Put number of sectors per cluster into Z, and don't shift if there is only
	; one sector per cluster.
	taz
	and #$fe
	beq ddop_gotclustercount

ddop14:
	; Divide cluster count by two.  This is a 32-bit value, so we have to use
	; ROR to do the shift, and propagate the carry bits between the bytes.
	; This also entails doing it from the last byte, backwards.

	; Get offset of start of (sectors_per_cluster) field
	lda dos_disk_table_offset
	ora #fs_fat32_cluster_count
	; get offset of last byte in this field
	clc 
	adc #$03  
	tay

	ldx #$03
	clc
ddop15:	lda dos_disk_table,y
	ror
	sta dos_disk_table,y
	dey
	dex
	bpl ddop15

	tza
	lsr
	taz
	and #$fe
	bne ddop14
ddop_gotclustercount:

	; Re-get sectors per cluster (and store in dos_disk_table entry)
	; (this was destroyed in the calculation above)
	lda dos_disk_table_offset
	ora #fs_fat32_sectors_per_cluster
	tay
	lda [sd_sectorbuffer+$0D]
	sta dos_disk_table,y

	; filter out non-FAT32 filesystems
	; NOTE: FAT32 can have as few as 65525 clusters, but we do not support
	; such file systems, which should be rare, anyway.

	lda dos_disk_table_offset
	ora #fs_fat32_sectors_per_cluster
	tay
	lda #$08
	sta dos_error_code
	lda dos_disk_table+3,y
	ora dos_disk_table+2,y
	beq partitionerror

	; Now get cluster of root directory.
	lda dos_disk_table_offset
	ora #fs_fat32_root_dir_cluster
	tay
	ldx #$03
ddop16:	lda [sd_sectorbuffer+$2C],x
	sta dos_disk_table,y
	dex
	bpl ddop16

	; We have now set the following fields:
	; fs_fat32_length_of_fat
	; fs_fat32_system_sectors
	; fs_fat32_reserved_clusters
	; fs_fat32_root_dir_cluster
	; fs_fat32_sectors_per_cluster
	; fs_fat32_fat_copies
	; fs_fat32_cluster0_sector
	; Our caller has set:
	; fs_start_sector
	; fs_sector_count
	; So all that is left for us is to set fs_type_and_source to $0F
	; to indicate FAT32 filesystem on the SD card ...
	lda dos_disk_table_offset
	ora #fs_type_and_source
	tay
	lda #$0f
	sta dos_disk_table,y

	; ... and increment the number of disks we know
	inc dos_disk_count

dos_return_success:
	; Return success
	lda #$00
	sta dos_error_code
	sec
	rts

dos_return_error:
	clc
	rts

dos_set_current_disk:
	; Is disk number valid?
	lda dos_errorcode_no_such_disk
	cpx dos_disk_count
	bcs partitionerror
	sec

	stx dos_disk_current_disk
	txa
	asl
	asl
	asl
	asl
	asl
	sta dos_disk_table_offset
	
	rts

dos_cdroot:
	; Change to root directory on specified disk
	; (Changes current disk if required)
	; X = disk

	jsr dos_set_current_disk

	; get offset of disk entry
	ldx dos_disk_table_offset
	lda [dos_disk_table+fs_fat32_root_dir_cluster+0],x
	sta dos_disk_cwd_cluster
	lda [dos_disk_table+fs_fat32_root_dir_cluster+1],x
	sta dos_disk_cwd_cluster+1
	lda #$00
	sta dos_disk_cwd_cluster+2
	sta dos_disk_cwd_cluster+3

	; Nothing else to do, as it doesn't actually affect any existing DOS activity,
	; only future file/directory operations.

	jmp dos_return_success

dos_cluster_to_sector:
	; convert a cluster number in dos_current_cluster into a sector number
	; pre-loaded into SD address registers
	; It is assumed to be on the current disk

	ldx #$03
dcts0:	lda dos_current_cluster,x
	sta $d681,x
	dex
	bpl dcts0

	; now shift it left according to fs_sectors_per_cluster
	ldx dos_disk_table_offset	
	lda dos_disk_table+fs_fat32_sectors_per_cluster,x
	tay
	and #$fe
	beq multipliedclusternumber
dcts1:	clc
	rol $D681
	rol $D682
	rol $D683
	rol $D684
	tya
	lsr
	tay
	and #$fe
	bne dcts1
multipliedclusternumber:
	ldx #$00
mmm1:	lda $d681,x
	inx
	cpx #$04
	bne mmm1

	; skip over filesystem reserved and FAT sectors
	lda dos_disk_table_offset	
	ora #fs_fat32_cluster0_sector
	tay
	ldx #$00
	clc
	php
l23:	plp
	lda $D681,x
	adc dos_disk_table,y
	sta $D681,x
	php
	iny
	inx
	cpx #$04
	bne l23
	plp	

	; add start sector of partition
	lda dos_disk_table_offset	
	ora #fs_start_sector
	tay
	ldx #$00
	clc
	php
l24:	plp
	lda $D681,x
	adc dos_disk_table,y
	sta $D681,x
	php
	iny
	inx
	cpx #$04
	bne l24
	plp

	; XXX - Check that result does not exceed fs_start_sector+fs_sector_count
	; and run over into another partition

	; return success
	sec
	rts


dos_requested_filename_to_uppercase:
	; Convert filename to upper case for comparison
	ldx dos_requested_filename_len
	cpx #$3f
	lda dos_errorcode_name_too_long
	bcs dos_return_error
drftu1:	lda dos_requested_filename,x
	jsr toupper
	sta dos_requested_filename,x
	inx
	cpx #dos_requested_filename_len
	bne drftu1
	sec
	rts

dos_get_free_descriptor:
	ldx #$00
dgfd1:	txa
	asl
	asl
	asl
	asl
	lda [dos_file_descriptors+dos_filedescriptor_offset_diskid],x
	cmp #$FF
	beq dgfd_found_free
	inx
	cpx #dos_filedescriptor_max
	bne dgfd1
	lda #dos_errorcode_too_many_open_files
	jmp dos_return_error
dgfd_found_free:
	; Clear descriptor entry
	ldy #$0f
	lda #$00
dgfd2:	sta dos_file_descriptors,y
	dey
	bne dgfd2

	; Return file descriptor in X
	stx dos_current_file_descriptor
	txa
	asl
	asl
	asl
	asl
	sta dos_current_file_descriptor_offset
	sec
	rts
	

dos_findfile:
	; Search for file in current directory

	; Convert name to upper case for searching
	jsr dos_requested_filename_to_uppercase
	bcc dos_return_error

	; Open the current directory as a file
	jsr dos_get_free_descriptor
	bcc dos_return_error

	; get offset in file descriptor table
	txa
	asl
	asl
	asl
	asl
	tay

	; load cluster of dir into file descriptor
	ldx #$00
dff1:	lda dos_disk_cwd_cluster,x
	sta [dos_file_descriptors+dos_filedescriptor_offset_startcluster],x
	inx
	cpx #$04
	bne dff1
	jsr dos_cluster_to_sector

	jsr dos_open_current_file
	bcc dos_return_error

	; Directory is now open, and we can read a sector at a time and look at
	; file entries.
dff2:
	; Get next directory entery
	jsr dos_readdir_read_current_entry

	; Compare dos_dirent_longfilename with dos_requested_filename

	; Do the cheap check of comparing the lengths first
	lda dos_dirent_longfilename_length
	cmp dos_requested_filename_len
	bne dff3

	; lengths match, so compare bytes
	ldx dos_dirent_longfilename_length
	dex
dff4:	lda dos_dirent_longfilename,x
	cmp dos_requested_filename,x
	bne dff3
	dex
	bpl dff4

	; File names match, so return success
	sec
	rts

dff3:
	; See if there is a next entry
	jsr dos_readdir_advance_to_next_entry
	bcs dff2


	lda #dos_errorcode_not_implemented
	jmp dos_return_error

dos_readdir_read_current_entry:
	; Get the current file entry.
	; This requires parsing the current directory entry onwards, accumulating
	; long filename parts as required.  We only support filenames to 64 chars,
	; so long names longer than that will get ignored.
	; LFN entries have an attribute byte of $0F (normally indicates volume label)
	; LFN entries use 16-bit unicode values. For now we will just keep the lower
	; byte of these

	; XXX - Not implemented
	rts

dos_readdir_advance_to_next_entry:
	; Add $20 to file offset, and read next sector as required

	; XXX - Not implemented
	clc
	rts


dos_open_current_file:
	; copy start cluster to current cluster, and zero position in file
	jsr dos_get_file_descriptor_offset

	sec
	rts


dos_get_file_descriptor_offset:
	lda dos_current_file_descriptor
	asl
	asl
	asl
	asl
	tax
	rts

dos_set_current_cluster_from_file:
	; copy cluster number in file to current cluster
	jsr dos_get_file_descriptor_offset
	ora dos_filedescriptor_offset_currentcluster
	tay
	ldx #$00
dfrcs1:	lda dos_file_descriptors,y
	sta dos_current_cluster,x
	inx
	cpx #$04
	bne dfrcs1
	rts

dos_file_read_current_sector:
	jsr dos_set_current_cluster_from_file
	jsr dos_cluster_to_sector

	; Add sector within cluster
	jsr dos_get_file_descriptor_offset
	ora dos_filedescriptor_offset_sectorincluster
	tay
	ldx #$00
	clc
	lda dos_file_descriptors,y
	bne dfrcs4
dfrcs2: lda #$00
dfrcs4:
	adc $d681,x
	sta $d681,x
	bcc dfrcs_inced
	inx
	cpx #$04
	bne dfrcs2
dfrcs_inced:

	jsr sd_fix_sectornumber
	jmp sd_readsector

dos_file_advance_to_next_sector:
	; Increment file position offset by 2 pages
	lda dos_current_file_descriptor_offset
	ora dos_filedescriptor_offset_fileoffset
	tay
	lda dos_file_descriptors,y
	clc
	adc #$02
	sta dos_file_descriptors,y
	bcc dfatns1
	inc dos_file_descriptors+1,y
	bne dfatns1
	inc dos_file_descriptors+2,y
dfatns1:
	; increase sector
	lda dos_current_file_descriptor_offset
	ora dos_filedescriptor_offset_sectorincluster
	tay
	ldx dos_disk_table_offset
	inc dos_file_descriptors,y
	lda dos_file_descriptors,y
	cmp dos_disk_table,x
	; and if necessary, advance to next cluster
	beq dos_file_advance_to_next_cluster
	sec
	rts
	
dos_file_advance_to_next_cluster:
	; set to sector 0 in cluster
	lda dos_current_file_descriptor_offset
	ora dos_filedescriptor_offset_sectorincluster
	tay
	lda #$00
	sta dos_file_descriptors,y

	; read chained cluster number for fs_clusternumber

	; FAT32 uses 32-bit cluster numbers.
	; 512 / 4 = 128 cluster numbers per sector.
	; To get the sector of the FAT containin a particular
	; cluster entry, we thus need to shift the cluster number
	; right 7 bits.  Then we add the start sector number of the FAT.

	jsr dos_set_current_cluster_from_file	

	; copy cluster to sector number
	ldx #$03
dfanc1:
	lda dos_current_cluster,x
	sta dos_current_sector,x
	dex
	bpl dfanc1

	; Remember low byte of cluster number so that we can pull the
	; cluster number for the next cluster out of the FAT sector
	lda dos_current_cluster
	sta dos_scratch_vector

	; shift right 7 times
	ldy #$07
dfanc2:	clc		
	ror dos_current_cluster+3
	ror dos_current_cluster+2
	ror dos_current_cluster+1
	ror dos_current_cluster+0
	dey
	bne dfanc2

	; add start of partition offset
	ldy dos_disk_table_offset
	tya
	ora #fs_start_sector
	tay
	ldx #$00
	clc
	php
dfanc3:	plp
	lda dos_current_cluster,x
	adc dos_disk_table,y
	sta dos_current_cluster,x
	php
	iny
	inx
	cpx #$04
	bne dfanc3
	plp

	; add start of fat offset
	ldy dos_disk_table_offset
	tya
	ora #fs_fat32_system_sectors
	tay
	ldx #$00
	clc
	php
dfanc4:	plp
	lda dos_current_cluster,x
	adc dos_disk_table,y
	sta $d681,x
	php
	inx
	cpx #$02
	bne dfanc4
dfanc44:
	plp
	lda dos_current_cluster,x
	adc #$00
	sta $d681,x
	php
	inx
	cpx #$04
	bne dfanc44

	plp

	; turn sector number into byte address for non-SDHC cards
	jsr sd_fix_sectornumber

	; read FAT sector
	jsr sd_readsector
	bcc gfail

	; now read the right four bytes out.
	; cluster number needs to be shifted left 2 bits.
	; we only need the lowest order byte.
	; Get low byte of old cluster number from dos_scratch_vector
	; where we put it.
	lda dos_scratch_vector
	asl
	asl
	tax

	; get offset to current cluster field in current file descriptor ...
	lda dos_current_file_descriptor_offset
	ora #dos_filedescriptor_offset_currentcluster
	tay
	; ... and keep it handy, because we will need it a few times
	sty dos_scratch_vector+1

	lda dos_scratch_vector
	and #$40
	bne dfanc_high
dfanc6:	lda $de00,x
	sta dos_file_descriptors,y
	inx
	iny
	cpy #$04
	bne dfanc6
	bra dfanc_check
dfanc_high:
	lda $df00,x
	sta dos_file_descriptors,y
	inx
	iny
	cpy #$04
	bne dfanc_high
dfanc_check:
	; check that resulting cluster number is valid.

	; get current cluster field address again
	ldy dos_scratch_vector+1

	; First, only the lower 28-bits are valid
	lda dos_file_descriptors+3,y
	and #$0f
	sta dos_file_descriptors+3,y

	; Now check for special values:
	; cluster 0 is invalid
	lda dos_file_descriptors+3,y
	ora dos_file_descriptors+2,y
	ora dos_file_descriptors+1,y
	ora dos_file_descriptors,y
	cmp #$00
	beq dfanc_fail
	; $FFFFFF7 = bad cluster
	; $FFFFFFF = end of file
	lda dos_file_descriptors+3,y
	cmp #$0f
	bne dfanc_ok
	lda dos_file_descriptors+2,y
	cmp #$ff
	bne dfanc_ok
	lda dos_file_descriptors+1,y
	cmp #$ff
	bne dfanc_ok
	lda dos_file_descriptors,y
	cmp #$ff
	beq dfanc_fail
	cmp #$f7
	beq dfanc_fail

dfanc_ok:
	; cluster number is okay
	sec
	rts

dfanc_fail:
	lda #dos_errorcode_invalid_cluster
	jmp dos_return_error



dos_readfileintomemory:
	; file name must be already loaded into dos_requested_filename,
	; with length in dos_requreste_filename_length

	; Clear number of sectors read
	ldx #$00
	stx dos_sectorsread
	stx dos_sectorsread+1

	jsr dos_findfile
	bcc dos_return_error

	jsr dos_openfile
	bcc dos_return_error

	jsr sd_map_sectorbuffer

drfim_sector_loop:
	jsr dos_file_read_current_sector
	bcc drfim_eof
	
	; copy sector to memory
	ldx #$00
	ldz #$00
drfim_rr1:
	lda $de00,x
	nop ; 32-bit pointer access follows
	sta (<dos_file_loadaddress),z
	inz
	inx
	bne drfim_rr1
	inw <dos_file_loadaddress+1
drfim_rr1b:
	lda $df00,x
	nop ; 32-bit pointer access follows
	sta (<dos_file_loadaddress),z
	inz
	inx
	bne drfim_rr1b

	jsr dos_file_advance_to_next_sector
	
	; We only allow loading into a 16MB space
	; Provided that we check the load address before starting,
	; this ensures that a user-land request cannot load a huge file
	; that eventually overwrites the hypervisor and results in privilege
	; escalation.
	inw <dos_file_loadaddress+1

	; Increment number of sectors read (16 bit valie)
	inw dos_sectorsread
	; see if there is another sector
	bne drfim_sector_loop

	; File is >65535 sectors (32MB), report error
	lda #dos_errorcode_file_too_long
	jmp dos_return_error
drfim_eof:
	jmp dos_return_success