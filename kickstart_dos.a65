	.alias os_version  $0101
	.alias dos_version $0101
	.alias constant_partition_type_fat32_chs $0b
	.alias constant_partition_type_fat32_lba $0c
	
dos_and_process_trap:
	; Sub-function is selected by X.
	; Bits 6-1 are the only ones used.
	; Mask out bit 0 so that indirect jmp's are valid.
	txa
	and #$FE
	; to save memory we only allow this table to be 128 bytes long,
	; thus we have to check that bit 7 is clear.
	bmi invalid_subfunction
	tax
	jmp (dos_and_process_trap_table,x)
dos_and_process_trap_table:
	; $00 - $0E
	.word trap_dos_getversion
	.word trap_dos_getdefaultdrive
	.word trap_dos_selectdrive
	.word trap_dos_getdisksize
	.word trap_dos_getcwd
	.word trap_dos_chdir
	.word trap_dos_mkdir
	.word trap_dos_rmdir
	; $10 - $1E
	.word trap_dos_opendir
	.word trap_dos_readdir
	.word trap_dos_closedir
	.word trap_dos_mkfile
	.word trap_dos_openfile
	.word trap_dos_closefile
	.word trap_dos_readfile
	.word trap_dos_writefile
	; $20 - $2E
	.word trap_dos_seekfile
	.word trap_dos_rmfile
	.word trap_dos_fstat
	.word trap_dos_rename
	.word trap_dos_filedate
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $30 - $3E
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $40 - $4E
	.word trap_dos_d81attach
	.word trap_dos_d81detach
	.word trap_dos_d81writeen
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $50 - $5E
	.word trap_dos_gettasklist
	.word trap_dos_sendmessage
	.word trap_dos_receivemessage
	.word trap_dos_writeintotask
	.word trap_dos_readoutoftask
	.word invalid_subfunction
	.word invalid_subfunction
	.word invalid_subfunction
	; $70 - $7E
	.word trap_dos_terminateothertask
	.word trap_dos_create_task_native
	.word trap_dos_load_into_task
	.word trap_dos_create_task_c64
	.word trap_dos_create_task_c65
	.word trap_dos_exit_and_switch_to_task
	.word trap_dos_switch_to_task
	.word trap_dos_exit_task

; Return OS and DOS version.
; A/X = OS Version major/minor
; Z/Y = DOS Version major/minor
trap_dos_getversion:
	lda #<os_version
	sta hypervisor_x
	lda #>os_version
	sta hypervisor_a
	lda #<dos_version
	sta hypervisor_z
	lda #>dos_version
	sta hypervisor_y
	jmp return_from_trap_with_success

trap_dos_getdefaultdrive:
trap_dos_selectdrive:
trap_dos_getdisksize:
trap_dos_getcwd:
trap_dos_chdir:
trap_dos_mkdir:
trap_dos_rmdir:
trap_dos_opendir:
trap_dos_readdir:
trap_dos_closedir:
trap_dos_mkfile:
trap_dos_openfile:
trap_dos_closefile:
trap_dos_readfile:
trap_dos_writefile:
trap_dos_seekfile:
trap_dos_rmfile:
trap_dos_fstat:
trap_dos_rename:
trap_dos_filedate:
trap_dos_d81attach:
trap_dos_d81detach:
trap_dos_d81writeen:
trap_dos_gettasklist:
trap_dos_sendmessage:
trap_dos_receivemessage:
trap_dos_writeintotask:
trap_dos_readoutoftask:
trap_dos_terminateothertask:
trap_dos_create_task_native:
trap_dos_load_into_task:
trap_dos_create_task_c64:
trap_dos_create_task_c65:
trap_dos_exit_and_switch_to_task:
trap_dos_switch_to_task:
trap_dos_exit_task:
	jmp invalid_subfunction;



; Clear all file descriptors.
; This just consists of setting the drive number to $ff,
; which indicates "no such drive"
; Drive number field is first byte of file descriptor for convenience
dos_clear_filedescriptors:
	lda #$ff
	sta currenttask_filedescriptor0
	sta currenttask_filedescriptor1
	sta currenttask_filedescriptor2
	sta currenttask_filedescriptor3
	rts

; Read partition table from SD card.
; Add all FAT32 partitions to our list of known disks.
; This routine assumes that the SD card has been reset and is ready to
; service requests.
; XXX - We don't support extended partition tables! Only the old-fashion
; 4 DOS partitions.  We might get excited and add support for them later,
; but 
dos_read_partitiontable:

	; clear error code
	lda #0
	sta dos_error_code

	; Clear the list of known disks
	jsr dos_initialise_disklist

	jsr dos_read_mbr
	bcc drpt_fail

	; Make the sector buffer visible
	jsr sd_map_sectorbuffer

	; check for $55AA MBR signature
	lda [sd_sectorbuffer+$1FE]
	cmp #$55
	bne drpt_fail
	lda [sd_sectorbuffer+$1FF]
	cmp #$AA
	bne drpt_fail

	; Partitions start at offsets $1BE, $1CE, $1DE, $1EE
	; so consider each in turn.  Opening the partition causes other sectors to
	; be read, so we must re-read the MBR between each

	; get pointer to second half of sector buffer so that we can access the
	; partition entries as we see fit.
	lda #<[sd_sectorbuffer+$1BE]
	sta dos_scratch_vector
	lda #>[sd_sectorbuffer+$1BE]
	sta dos_scratch_vector+1

	jsr dos_consider_partition_entry
	
	jsr dos_read_mbr
	bcc drpt_fail
	lda #<[sd_sectorbuffer+$1CE]
	sta dos_scratch_vector
	jsr dos_consider_partition_entry

	jsr dos_read_mbr
	bcc drpt_fail
	lda #<[sd_sectorbuffer+$1DE]
	sta dos_scratch_vector
	jsr dos_consider_partition_entry

	jsr dos_read_mbr
	bcc drpt_fail
	lda #<[sd_sectorbuffer+$1EE]
	sta dos_scratch_vector
	jsr dos_consider_partition_entry

	rts

dos_read_mbr:
	; Offset zero  on disk
	lda #0
	sta sd_address_byte0
	sta sd_address_byte1
	sta sd_address_byte2
	sta sd_address_byte3

	; Read sector
	jsr sd_readsector
	bcc drpt_fail
	rts

dos_initialise_disklist:
	lda #0
	sta dos_disk_count
	rts

dos_consider_partition_entry:

	lda #$00
	sta dos_error_code

	; Offset within partition table entry of partition type
	ldy #$04
	; Get partition type byte
	lda (<dos_scratch_vector),y

	; We like FAT32 partitions, whether LBA or CHS addressed, although we actually
	; use LBA addressing.  XXX - Can this cause problems for CHS partitions?
	; (SD cards which must really use LBA, can still show up with CHS partitions!
	;  this is really annoying.)
	cmp #constant_partition_type_fat32_lba
	beq partitionisinteresting
	cmp #constant_partition_type_fat32_chs
	beq partitionisinteresting
	lda #$0f
	sta dos_error_code
	jmp partitionisnotinteresting

partitionisinteresting:
	lda #$01
	sta dos_error_code

	; Partition is FAT32, so add it to the list

	; Disk structures in dos_disk_table are 32 bytes long, so shift count left
	; 5 times to get offset in dos disk list table
	lda dos_disk_count
	asl
	asl
	asl
	asl
	asl
	tax

	; Copy relevant fields into place
	; These are start of partition and length of partition (both in sectors)
	; XXX - This requires that our dos_disk_table has these two fields together
	; at the start of the structure.
	ldy #$08
dcpe1:	lda (<dos_scratch_vector),y
	sta dos_disk_table,x
	inx
	iny
	cpy #$10
	bne dcpe1

	; Examine the internals of the partition to get the remaining fields.
	; At this point we no longer use the contents of the MBR
	lda #$02
	sta dos_error_code
	lda dos_disk_count
	jsr dos_disk_openpartition
	bcc partitionerror

	; Check if partition is bootable (or the only partition)
	; If so, make the partition the default disk
	lda dos_disk_count
	beq makethispartitionthedefault
	ldy #$00
	lda (<dos_scratch_vector),y
	bpl dontmakethispartitionthedefault
makethispartitionthedefault:
	lda dos_disk_count
	sta dos_default_disk
dontmakethispartitionthedefault:

partitionisnotinteresting:
	; return OK
	sec
	rts

drpt_fail:
	
partitionerror:
	; return ERROR
	clc
	rts

; Examine a partitiomn to see if we can mount it.
; This routine fills in the missing fields for the disk entry as required.
; It assumes that fs_start_sector and fs_sector_count have been correctly set.
; Each disk entry consists of;
; Offset $00 - starting sector (4 bytes)
  	 .alias fs_start_sector $00
; Offset $04 - sector count (4 bytes)
  	 .alias fs_sector_count $04
; Offset $08 - Filesystem type & media source ($0x = FAT32, $xF = SD card, others reserved for now)
  	 .alias fs_type_and_source $08
; Remaining bytes are filesystem dependent:
; For FAT32:
; Offset $09 - length of fat (4 bytes) (FAT starts at fs_fat32_system_sectors)
  	 .alias fs_fat32_length_of_fat $09
; Offset $0D - system sectors (2 bytes)
  	 .alias fs_fat32_system_sectors $0D
; Offset $0F - reserved clusters (1 byte)
  	 .alias fs_fat32_reserved_clusters $0F
; Offset $10 - root dir cluster (2 bytes) 
  	 .alias fs_fat32_root_dir_cluster $10
; Offset $12 - cluster count (4 bytes)
  	 .alias fs_fat32_cluster_count $12
; Offset $16 - sectors per cluster
  	 .alias fs_fat32_sectors_per_cluster $16
; Offset $17 - copies of FAT
  	 .alias fs_fat32_fat_copies $17
; Offset $18 - first sector of cluster zero (4 bytes)
  	 .alias fs_fat32_cluster0_sector $18
; Offset $1C - Four spare bytes.
dos_disk_openpartition:
	; A contains the disk number we are trying to open.
	lda #$00
	sta dos_error_code

	; Load first sector of file system and parse.
	; This is the Volume Boot Record

	; Get offset of disk entry in our disk table structure 
	asl
	asl
	asl
	asl
	asl
	sta dos_disk_table_offset

	; Now pull the start sector from the structure and get ready to request
	; that structure from the SD card.
	ora #fs_start_sector
	tay
	ldx #$00
ddop1:	lda dos_disk_table,y
	sta sd_address_byte0,x
	iny
	inx
	cpx #$04
	bne ddop1
	; Convert sector number to byte offset for non-HC SD cards
	jsr sd_fix_sectornumber
	lda #$03
	sta dos_error_code
	jsr sd_readsector
	bcc partitionerror

	; We now have the sector, so parse.

	jsr sd_map_sectorbuffer

	; Check for 55/AA singature
	lda #$04
	sta dos_error_code
	lda [sd_sectorbuffer+$1FE]
	cmp #$55
	bne partitionerror
	lda [sd_sectorbuffer+$1FF]	
	cmp #$AA
	bne partitionerror

	; Start populating fields

	; Filter out obviously FAT16/FAT12 file systems
	lda #$05
	sta dos_error_code
	lda [sd_sectorbuffer+$11]
	bne partitionerror

	; get # copies of fat
	lda dos_disk_table_offset
	ora #fs_fat32_fat_copies
	tay
	lda [sd_sectorbuffer+$10]
	sta dos_disk_table,y

	; With root directory entries = 0, the reserved sector count
	; is the number of reserved sectors, plus (copies of fat) *
	; (sectors in one copy of the fat).
	; the first FAT begins immediately after the reserved sectors

	; Determine system sector count
	; (= reserved sectors + fat_count * fat_sectors)
	; $20 + $EE5 + $EE5 = $1DEA
	; plus partition offset = $81 = $1E6B
	; partition length = $3BAF7F
	; $08 sectors / cluster
	; so data sectors in partition = $3BAF7F - $1DEA = $3B9195
	; = $77232 clusters
	
	; Reserved sector field on disk is only 2 bytes!
	lda dos_disk_table_offset
	ora #fs_fat32_system_sectors	
	tay
	ldx #$00
ddop10:	lda [sd_sectorbuffer+$0E],x
	sta dos_disk_table,y
	iny
	inx
	cpx #$02
	bne ddop10

	; Store length of one copy of the FAT
	lda dos_disk_table_offset
	ora #fs_fat32_length_of_fat
	tay
	ldx #$00
ddop11:	lda [sd_sectorbuffer+$24],x
	sta dos_disk_table,y
	iny
	inx
	cpx #$04
	bne ddop11

	; Get number of reserved clusters.  We only allow upto 255 reserved
	; clusters, so report an error if the upper two bytes are not both zero
	lda #$06
	sta dos_error_code
	lda [sd_sectorbuffer+$2C+1]
	ora [sd_sectorbuffer+$2C+2]
	ora [sd_sectorbuffer+$2C+3]
	; XXX - 16 bit BNE should be fine here!
	;	bne partitionerror
	beq ddop11ok
	jmp partitionerror
ddop11ok:
	; <64K reserved clusters, so file system passes this test -- just copy number
	ldy dos_disk_table_offset
	lda [sd_sectorbuffer+$2C]
	sta [dos_disk_table+fs_fat32_reserved_clusters],y

	; Now work out the sector of cluster 0, by adding the length of
	; each FAT to fs_fat32_system_sectors to start of partition.
	; For efficiency, we pull the fields we need out of the sector buffer,
	; instead of working out their offsets in the disk entry structure.

	; Start with fs_fat32_system_sectors (which is 16 bits)
	lda dos_disk_table_offset
	ora #fs_fat32_system_sectors
	tay	
	lda dos_disk_table_offset
	ora #fs_fat32_cluster0_sector
	tax
	ldz #$02
ddop2:	lda dos_disk_table,y
	sta dos_disk_table,x
	iny
	inx
	dez
	bne ddop2
	; clear top 16 bits of cluster0_sector
	tza
	sta [dos_disk_table+0],x
	sta [dos_disk_table+1],x
	
	; Now add length of fat for each copy of the fat
	lda #$07
	sta dos_error_code
	ldz [sd_sectorbuffer+$10]     ; # of FAT copies
	beq partitionerror ; There must be at least one copy of the FAT!
ddop_addnextfatsectors:
	lda dos_disk_table_offset
	ora #fs_fat32_cluster0_sector
	tay
	ldx #$00
	clc
	php
ddop12:	plp
	lda dos_disk_table,y           ; cluster0_sector
	adc [sd_sectorbuffer+$24],x    ; sectors per fat
	sta dos_disk_table,y           ; cluster0_sector
	php
	iny
	inx
	cpx #$04
	bne ddop12
	plp
	dez
	bne ddop_addnextfatsectors

	; Next, we temporarily need the number of data sectors, so that we can work
	; out the number of clusters in the file system.
	; This is the total number of sectors in the partition, minus the number of
	; reserved sectors.

	lda dos_disk_table_offset
	ora #fs_fat32_cluster0_sector
	tax
	lda dos_disk_table_offset
	ora #fs_fat32_cluster_count
	tay

	; Subtract (reserved sectors = 16 bits) from
	; (length of filesystem in sectors = 32 bits)

	lda dos_disk_table_offset
	ora #fs_fat32_system_sectors
	tax
	lda dos_disk_table_offset
	ora #fs_fat32_cluster_count
	tay
	sec
	lda [sd_sectorbuffer+$20+0]
	sbc [dos_disk_table+0],x
	sta [dos_disk_table+0],y
	lda [sd_sectorbuffer+$20+1]
	sbc [dos_disk_table+1],x
	sta [dos_disk_table+1],y
	lda [sd_sectorbuffer+$20+2]
	sbc #$00
	sta [dos_disk_table+2],y
	lda [sd_sectorbuffer+$20+3]
	sbc #$00
	sta [dos_disk_table+3],y
	

	; Get sectors per cluster (and store in dos_disk_table entry)
	; (this gets destoryed below, so we have to re-read it again after) 
	lda dos_disk_table_offset
	ora #fs_fat32_sectors_per_cluster
	tay
	lda [sd_sectorbuffer+$0D]
	sta dos_disk_table,y

	; Now divide number of sectors available for clusters by the number of
	; sectors per cluster to obtain the number of actual clusters in the file
	; system.  Since clusters must contain a power-of-two number of sectors,
	; we can implement the division using a simple shift.

	; copy number of sectors into number of sectors ready for shifting down
	

	; Put number of sectors per cluster into Z, and don't shift if there is only
	; one sector per cluster.
	taz
	and #$fe
	beq ddop_gotclustercount

ddop14:
	; Divide cluster count by two.  This is a 32-bit value, so we have to use
	; ROR to do the shift, and propagate the carry bits between the bytes.
	; This also entails doing it from the last byte, backwards.

	; Get offset of start of (sectors_per_cluster) field
	lda dos_disk_table_offset
	ora #fs_fat32_cluster_count
	; get offset of last byte in this field
	clc 
	adc #$03  
	tay

	ldx #$03
	clc
ddop15:	lda dos_disk_table,y
	ror
	sta dos_disk_table,y
	dey
	dex
	bpl ddop15

	tza
	lsr
	taz
	and #$fe
	bne ddop14
ddop_gotclustercount:

	; Re-get sectors per cluster (and store in dos_disk_table entry)
	; (this was destroyed in the calculation above)
	lda dos_disk_table_offset
	ora #fs_fat32_sectors_per_cluster
	tay
	lda [sd_sectorbuffer+$0D]
	sta dos_disk_table,y

	; filter out non-FAT32 filesystems
	; NOTE: FAT32 can have as few as 65525 clusters, but we do not support
	; such file systems, which should be rare, anyway.

	lda dos_disk_table_offset
	ora #fs_fat32_sectors_per_cluster
	tay
	lda #$08
	sta dos_error_code
	lda dos_disk_table+3,y
	ora dos_disk_table+2,y
	beq partitionerror

	; Now get cluster of root directory.
	lda dos_disk_table_offset
	ora #fs_fat32_root_dir_cluster
	tay
	ldx #$03
ddop16:	lda [sd_sectorbuffer+$2C],x
	sta dos_disk_table,y
	dex
	bpl ddop16

	; We have now set the following fields:
	; fs_fat32_length_of_fat
	; fs_fat32_system_sectors
	; fs_fat32_reserved_clusters
	; fs_fat32_root_dir_cluster
	; fs_fat32_sectors_per_cluster
	; fs_fat32_fat_copies
	; fs_fat32_cluster0_sector
	; Our caller has set:
	; fs_start_sector
	; fs_sector_count
	; So all that is left for us is to set fs_type_and_source to $0F
	; to indicate FAT32 filesystem on the SD card ...
	lda dos_disk_table_offset
	ora #fs_type_and_source
	tay
	lda #$0f
	sta dos_disk_table,y

	; ... and increment the number of disks we know
	inc dos_disk_count

	; Return success
	lda #$00
	sta dos_error_code
	sec
	rts

	jmp partitionerror