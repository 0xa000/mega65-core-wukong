; C65GS Kick Start ROM.
; Paul Gardner-Stephen, 2014-2015.
;
; Purpose: 
; 1. Verify checksum of ROM area of slow RAM.
; 1. If checksum fails, load complete ROM from SD card.
; 2. Select default disk image for F011 emulation.
;
; The kickstart ROM is 16KB in length, and maps at $8000-$BFFF
; in hypervisor mode.
;
; Kickstart modifies RAM from $0000-$07FF (ZP, stack, 40-column
; screen) during normal boot.
;
; If Kickstart needs to load the ROM from SD card, then it may
; modify the first 64KB of fast ram.
;
; We will use the convention of C=0 means failure, and C=1 means
; success.
;
	.include "kickstart_machine.a65"

; scratch space in ZP space usually used by kernel
; we try to use address space not normally used by C64 kernel, so that
; it is possible to make calls to kickstart after boot.  Eventually
; the desire is to have an SYS call that brings up a menu that lets
; you choose a disk image from a list.
	.data 

	.org $ce00
	.space romslab 1
	.space screenrow 1

	.space checksum 4
	.space file_sectorsread 2

	; structure for partition table
	.space part_startsector 4

	; structure for FAT32 file system
	.space fs_startfat 4
	.space fs_syssectors 4
	.space fs_reservedclusters 4
	.space fs_rootdircluster 4
	.space fs_datasectors 4
	.space fs_clustercount 4
	.space fs_sectorspercluster 1

	; structure for current directory entry
	.space fs_currentdircluster 4
	.space fs_direntry 32
	.space fs_direntrynumber 1
	; structure for current open file
	.space fs_clusternumber 4
	.space fs_sector_in_cluster 1

	; variables for testing of D81 boot image
	.space d81_clusternumber 4
	.space d81_clustersneeded 2
	.space d81_clustercount 2

	; make sure that we don't go past the 256 byte page reserved for hypervisor scratch space
	.checkpc $CEFF

	.text

	.org $8000
;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor Trap entry points.
;;; 64 x 4 byte entries for user-land traps.
;;; some more x 4 byte entries for system traps (reset, page fault etc)
;;; ----------------------------------------------------------------------------
trap_entry_points:
	; Traps $00-$07 (user callable)
	jmp dos_and_process_trap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $08-$0F (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $10-$17 (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $18-$1F (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $20-$27 (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $28-$2F (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $30-$37
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $38-$3F (user callable)
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	; Traps $40-$4F (reset, page fault and other system-only traps)
	jmp reset_entry  ; Trap #$40
	nop
	jmp page_fault   ; Trap #$41
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop
	jmp nosuchtrap
	nop

	; Leave room for traps to $7F
	.advance $8200

;;; ----------------------------------------------------------------------------
;;; Hypervisor traps
;;; ----------------------------------------------------------------------------

;;; ----------------------------------------------------------------------------
;;; Illegal trap / trap sub-function handlers
;;; ----------------------------------------------------------------------------
; Traps are triggered by writing to $D640-$D67F
; and trap to $8000+((address & $3F)*4) in the hypervisor

; Routine for unimplemented/reserved traps
; (Consider replacing with trap to hypervisor error screen with option
;  to return?)
nosuchtrap:
	; set C flag for caller to indicate failure
	lda hypervisor_flags
	ora #$01   ; C flag is bit 0
	sta hypervisor_flags
	; set A to $FF
	lda #$ff
	sta hypervisor_a
	; return from hypervisor
	sta hypervisor_enterexit_trigger

; Return from trap with C flag clear to indicate success
return_from_trap_with_success:
	; set C flag for caller to indicate failure
	lda hypervisor_flags
	and #$FE   ; C flag is bit 0
	sta hypervisor_flags
	; return from hypervisor
	sta hypervisor_enterexit_trigger

return_from_trap_with_failure:
	; report error in A
	sta hypervisor_a
	lda hypervisor_flags
	ora #$01   ; C flag is bit 0
	sta hypervisor_flags
	; return from hypervisor
	sta hypervisor_enterexit_trigger	

invalid_subfunction:
	jmp nosuchtrap

;;; ----------------------------------------------------------------------------
;;; DOS, process control and related functions trap
;;; ----------------------------------------------------------------------------
		.include "kickstart_dos.a65"
;;; ----------------------------------------------------------------------------
;;; Virtual memory and memory management
;;; ----------------------------------------------------------------------------
		.include "kickstart_mem.a65"
;;; ----------------------------------------------------------------------------
;;; Task (process) management
;;; ----------------------------------------------------------------------------
		.include "kickstart_task.a65"
;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor Entry Point on reset
;;; ----------------------------------------------------------------------------
reset_machine_state:
		; get CPU state sensible
		sei
		cld
		see

		; sprites off		
		lda #$00
		sta $d017		

		lda #$7f
		sta $DC0D
		sta $DD0D
		lda #$00
		sta $D01A

		; We DO NOT need to mess with $01, because
		; the 4510 starts up with kickstart mapped at $8000-$BFFF 
		; enhanced ($FFD3xxx) IO page mapped at $D000,
		; and fast RAM elsewhere.

		; disable IRQ sources
		lda #$7f
		sta $DC0D
		sta $DD0D
		LDA #$00
		STA $D019

		sec
		jsr enhanced_io

		jsr resetdisplay
		jsr erasescreen
		jsr resetpalette

		rts

;;; ----------------------------------------------------------------------------
;;; CPU Hypervisor reset/trap routines
;;; ----------------------------------------------------------------------------

reset_entry:
kickstart_entry:
		jsr reset_machine_state

		; display welcome screen
		ldx #<msg_kickstart
		ldy #>msg_kickstart
		jsr printbanner
		; leave a blank line below kickstart banner
		ldx #<msg_blankline
		ldy #>msg_blankline
		jsr printmessage

		; check keyboard for 0-9 down to select alternate rom
		jsr keyboardread

		; If switch 8 and 9 are set, then wait forever for ethernet packets
		lda $d6f1
		and #$02
		beq normalboot
etherboot:
		ldx #<msg_etherkick
		ldy #>msg_etherkick
		jsr printmessage
		jsr setupethernet
etherloop:
		jsr checkethernet
		jmp etherloop

normalboot:
		; Try to read the MBR from the SD card
		ldx #<msg_tryingsdcard
		ldy #>msg_tryingsdcard
		jsr printmessage
tryreadmbr:
		jsr readmbr
		bcs gotmbr

		jmp tryreadmbr
		
gotmbr:
		jsr dos_read_partitiontable
		jsr readmbr

		ldx #<msg_sdcardfound
		ldy #>msg_sdcardfound
		jsr printmessage
		; got master boot record

		jsr sd_map_sectorbuffer

		; check for $55AA MBR signature
		lda $DFFE
		cmp #$55
		bne badfs
		lda $DFFF
		cmp #$AA
		bne badfs

		; read partition 1 details from $DFBE
		; $DFBE - $80 = bootable, $00 = inactive.  We ignore this
		; $DFC2 - Partition type
		; $DFC6 - Starting SECTOR number
		; $DFCA - Number of sectors in partition
		ldx #<msg_partitiondetails
		ldy #>msg_partitiondetails
		jsr printmessage
		; overwrite $ chars in template with hex digits
		ldy #$00
		ldz $DFC2
		jsr printhex
		ldz $DFC9
		stz part_startsector+3
		jsr printhex
		ldz $DFC8
		stz part_startsector+2
		jsr printhex
		ldz $DFC7
		stz part_startsector+1
		jsr printhex
		ldz $DFC6
		stz part_startsector+0
		jsr printhex
		ldz $DFCD
		jsr printhex
		ldz $DFCC
		jsr printhex
		ldz $DFCB
		jsr printhex
		ldz $DFCA
		jsr printhex

		; load start sector of partition into SD card sector register
		ldx #$03
l9:		lda part_startsector,x
		sta $D681,x
		dex
		bpl l9
		jsr sd_fix_sectornumber
		jsr sd_readsector
		bcc sdcarderror		

		; MILESTONE: Have boot sector of file system
	
		lda $DFFE
		cmp #$55
		bne badfs
		lda $DFFF
		cmp #$AA
		bne badfs

		; report file system info
		ldx #<msg_fsdetails
		ldy #>msg_fsdetails
		jsr printmessage			

		; sectors per cluster
		ldy #$00
		ldz $DE0D
		jsr printhex
		; reserved sectors
		ldz $DE0F
		jsr printhex
		ldz $DE0E
		jsr printhex
		; first cluster
		ldz $DE00+47
		jsr printhex
		ldz $DE00+46
		jsr printhex
		ldz $DE00+45
		jsr printhex
		ldz $DE00+44
		jsr printhex

		; The information of relevance we have now is:
		; $DE0D - sectors per cluster
		; $DE0E-$DE0F - reserved sectors
		; $DE10 - number of copies of FAT
		; $DE11 - Root dir entry count (0 on FAT32)
		; $DE20-$DE23 - number of sectors in the file system
		; $DE24-$DE27 - number of sectors in one copy of the FAT
		; $DE2C-$DE2F - number of reserved clusters
		
		; We need to work out if this is a FAT32 partition by working out
		; the number of clusters.  To work that out, we need to work out
		; the number of data sectors.  To work that out, we need to work out
		; the number of reserved sectors.
		
		; first, filter out obviously FAT16/FAT12 file systems
		lda $DE11
		bne badfs

		; With root directory entries = 0, the reserved sector count
		; is the number of reserved sectors, plus (copies of fat) *
		; (sectors in one copy of the fat).
		; the first FAT begins immediately after the reserved sectors
		ldx #$03
l11:		lda $DE0E,x
		sta fs_syssectors,x
		sta fs_startfat,x
		lda $DE2C,x
		sta fs_reservedclusters,x
		dex
		bpl l11
		lda #$00
		sta fs_syssectors+2
		sta fs_syssectors+3
		sta fs_startfat+2
		sta fs_startfat+3
		ldy $DE10
		beq addedfatsectors
addnextfatsectors:
		ldx #$00
		clc
		php
l12:		plp
		lda fs_syssectors,x
		adc $DE24,x
		sta fs_syssectors,x
		php
		inx
		cpx #$04
		bne l12
		plp
		dey
		bne addnextfatsectors
addedfatsectors:

		; also calculate number of data sectors
		sec
		ldx #$03
l13:		lda $DE20,x
		sbc fs_syssectors,x
		sta fs_datasectors,x
		sta fs_clustercount,x
		dex
		bpl l13		

		; from number of data sectors and sectors per cluster,
		; we can work out the number of clusters.
		lda $DE0D
		sta fs_sectorspercluster
		tay
		and #$fe
		beq gotclustercount
l14:
		ldx #$03
		clc
l15:		lda fs_clustercount,x
		ror
		sta fs_clustercount,x
		dex
		bpl l15
		tya
		lsr
		tay
		and #$fe
		bne l14
gotclustercount:

		; filter out non-FAT32 filesystems
		; NOTE: FAT32 can have as few as 65525 clusters, but we do not support
		; such file systems, which should be rare, anyway.
		lda fs_clustercount+3
		ora fs_clustercount+2
		beq badfs

		ldx #<msg_reservedsectors
		ldy #>msg_reservedsectors		
		jsr printmessage
		ldy #$00
		ldz fs_syssectors+3
		jsr printhex
		ldz fs_syssectors+2
		jsr printhex
		ldz fs_syssectors+1
		jsr printhex
		ldz fs_syssectors+0
		jsr printhex

		ldz fs_datasectors+3
		jsr printhex
		ldz fs_datasectors+2
		jsr printhex
		ldz fs_datasectors+1
		jsr printhex
		ldz fs_datasectors+0
		jsr printhex

		ldz fs_clustercount+3
		jsr printhex
		ldz fs_clustercount+2
		jsr printhex
		ldz fs_clustercount+1
		jsr printhex
		ldz fs_clustercount+0
		jsr printhex
	
		; Store cluster number of root directory
		ldx #$03
l16:		lda $DE2C,x
		sta fs_rootdircluster,x
		sta fs_clusternumber,x
		dex
		bpl l16

		; Load and display boot logo
		; Prepare 32-bit pointer for loading boot logo @ $0004000
		lda #$00
		sta <target_loadaddress+0
		lda #$40
		sta <target_loadaddress+1
		lda #$00
		sta <target_loadaddress+2
		lda #$00
		sta <target_loadaddress+3
		ldx #$0b
lr11:		lda txt_bootlogo,x
		sta target_filename,x
		dex
		bpl lr11
		jsr fs_readfileintomemory
		bcs logook
		
		ldx #<msg_nologo
		ldy #>msg_nologo
		jsr printmessage
logook:
		; iterate through directory entries looking for ordinary file 
		; KICKUP.G65 to load into hypervisor memory ...
		; ... but only if we are not running a kick-up'd kickstart now.
		lda $d67e
		beq nextdirectoryentry3

		; already kicked
		ldx #<msg_alreadykicked
		ldy #>msg_alreadykicked
		jsr printmessage
		jmp postkickup

nextdirectoryentry3:
		; Prepare 32-bit pointer for loading boot logo @ $0004000
		lda #$00
		sta <target_loadaddress+0
		lda #$40
		sta <target_loadaddress+1
		lda #$00
		sta <target_loadaddress+2
		lda #$00
		sta <target_loadaddress+3
		ldx #$0b
lr12:		lda txt_kickupfile,x
		sta target_filename,x
		dex
		bpl lr12
		jsr fs_readfileintomemory
		bcc nokickup

		; We have loaded kickup file, so jump into it.

		ldx #<msg_kickuploaded
		ldy #>msg_kickuploaded
		jsr printmessage
		ldy #$00
		ldz <zptempv32+3
		jsr printhex
		ldz <zptempv32+2
		jsr printhex
		ldz <zptempv32+1
		jsr printhex
		ldz <zptempv32+0
		jsr printhex

		; Use DMAgic to copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
		; (We have to copy the routine to do this to RAM, since we will
		; be replacing ourselves)
		ldx #$00
krc:		lda kickuproutine,x
		sta $3000,x
		inx
		bne krc
		jmp $3000

kickuproutine:
		; The following routine gets copied as-is to $3000 and run from there.
		; The DMA list is still available in the kickstart ROM when it gets
		; called, so we can just use it there, instead of working out where
		; it gets copied to

		; Set bottom 22 bits of DMA list address as for C65
		; (8MB address range).  Kickstart ROM is at $FFF8000, so $FF goes
		; in high-byte area
		lda #$ff
		sta $d702
		lda #$ff   
		sta $d704  ; dma list is in top MB of address space
		sta $d706  ; similarly destination of copy is top MB of address space
		lda #$00
		sta $d705  ; source of copy is bottom MB of address space
		lda #>kickupdmalist
		sta $d701
		lda #<kickupdmalist
		sta $d700
		; clear source/destination MB so that C65 ROM doesn't go bananas
		lda #$00
		sta $d706

		; copy complete, so mark ourselves upgraded, and jump into hypervisor
		; as though we were just reset.

		sta $d67e   ; mark ourselves as having kicked up
		jmp $8100

kickupdmalist:
		; copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
		; (MB offsets get set in routine)
		.byte $00 ; copy + last request in chain
		.word $4000 ; size of copy is 16KB
		.word $4000 ; starting at $4000
		.byte $00   ; of bank $0
		.word $8000 ; destination address is $8000
		.byte $0F   ; of bank $F
		.word $0000 ; modulo (unused)

couldntopenkickup:

nokickup:
		ldx #<msg_nokickup
		ldy #>msg_nokickup
		jsr printmessage
postkickup:

		; MILESTONE: Have file system properties.

		; Look for C65GS.D81 to mount for F011 emulation
		
		; for now indicate that there is no disk in drive
		lda #$00
		sta $d68b

		jsr fs_cd_rootdir
		jsr fs_opendir
		bcc sdcarderror

		; iterate through directory entries looking for ordinary file 
		; C65GS.D81
nextdirectoryentry2:
		jsr fs_readdir
		bcc nod81

		ldx #$00
l17c:		lda fs_direntry,x
		jsr toupper
		cmp txt_c65gsd81,x
		bne nextdirectoryentry2
		inx
		cpx #$0b
		bne l17c

		; this is the entry
		ldx #<msg_foundd81
		ldy #>msg_foundd81
		jsr printmessage

		; now we need to check that the file is long enough,
		; and also that the cluster are contiguous.

		; get cluster number from directory entry.
		jsr fs_setfile

		; get the starting sector number in case it is good
		jsr fs_clustertosector
		jsr sd_fix_sectornumber
		; copy to FDC starting sector register (but don't mark
		; disk as available yet)
		ldx #$03
l91:		lda $d681,x
		sta $d68c,x
		dex
		bpl l91
	
		; now check that file is long enough and has
		; contiguous clusters
		jsr fs_setfile
		ldx #$03
l92:		lda fs_clusternumber,x
		sta d81_clusternumber,x
		dex
		bpl l92

		; work out how many clusters we need
		; We need 1600 sectors, so halve for every zero tail
		; bit in sectors per cluster.  we can do this because
		; clusters in FAT must be 2^n sectors.
		lda #$00
		sta d81_clustercount 
		sta d81_clustercount+1
		lda #<1600
		sta d81_clustersneeded
		lda #>1600
		sta d81_clustersneeded+1
		ldz fs_sectorspercluster
l94:		tza
		and #$01
		bne d81nextcluster
		tza
		lsr
		taz
		lsr d81_clustersneeded+1
		ror d81_clustersneeded
		jmp l94				

d81nextcluster:
		; Now read through clusters and make sure that all is
		; well.
		
		; we start with the first cluster already read.

		; check that it matches expected cluster number
		ldx #$03
l95:		lda d81_clusternumber,x
		cmp fs_clusternumber,x
		bne d81isfragged
		dex
		bpl l95
		
		; increment number of expected clusters found.
		inc d81_clustercount
		bne l96
		inc d81_clustercount+1
l96:

		; increment expected cluster number
		clc
		lda d81_clusternumber
		adc #$01
		sta d81_clusternumber
		lda d81_clusternumber+1
		adc #$00
		sta d81_clusternumber+1
		lda d81_clusternumber+2
		adc #$00
		sta d81_clusternumber+2
		lda d81_clusternumber+3
		adc #$00
		sta d81_clusternumber+3

		jsr fs_getnextclusteroffile
		bcs d81nextcluster

		; read to end of D81 file, and it is contiguous
		; now check that it is the right length

		lda d81_clustersneeded
		cmp d81_clustercount
		bne d81wronglength
		
		lda d81_clustersneeded+1
		cmp d81_clustercount+1
		bne d81wronglength

		; D81 is good, so set flag 
		lda #$07
		sta $d68b
		ldx #<msg_d81mounted
		ldy #>msg_d81mounted
		jsr printmessage

		; all done, move on to loading the ROM
		jmp findrom

d81wronglength:
		ldx #<msg_d81wronglength
		ldy #>msg_d81wronglength
		jsr printmessage
		jmp findrom

d81isfragged:
		inc $d020
		ldx #$00
l98:		lda d81_clusternumber,x
		sta $0428,x
		lda fs_clusternumber,x
		sta $0430,x
		inx
		cpx #$04
		bne l98

		ldx #<msg_d81fragged
		ldy #>msg_d81fragged
		jsr printmessage
		jmp findrom

nod81:
		; we couldn't find the D81 file, so tell the user
		ldx #<msg_nod81
		ldy #>msg_nod81
		jsr printmessage

findrom:
		; Check state of current ROM
		jsr checkromok
		bcc loadrom

		; ROM is loaded and ready, so transfer control
		; to it.
		ldx #<msg_romok
		ldy #>msg_romok
		jsr printmessage
		jmp go64

loadrom:
		; ROM is not loaded, so try to load it, or prompt
		; for user to insert SD card
		ldx #<msg_rombad
		ldy #>msg_rombad
		jsr printmessage


		; Load CHARROM.G65 into character ROM
		ldx #$0b
lr1:		lda txt_c65gscharrom,x
		sta target_filename,x
		dex
		bpl lr1

		; Prepare 32-bit pointer for loading whole ROM ($0020000)
		lda #$00
		sta <target_loadaddress+0
		lda #$E0
		sta <target_loadaddress+1
		lda #$F7
		sta <target_loadaddress+2
		lda #$0F
		sta <target_loadaddress+3

		jsr fs_readfileintomemory
		bcs loadedcharromok

		ldx #<msg_charrombad
		ldy #>msg_charrombad
		jsr printmessage
		jmp loadc65rom

loadedcharromok:
		ldx #<msg_charromloaded
		ldy #>msg_charromloaded
		jsr printmessage
		ldy #$00
		ldz file_sectorsread+1
		jsr printhex
		ldz file_sectorsread
		jsr printhex
		
		
loadc65rom:
		; set file name of file to load (8.3 DOS name)
		ldx #$0b
lr1b:		lda txt_c65gsrom,x
		sta target_filename,x
		dex
		bpl lr1b

		; Prepare 32-bit pointer for loading whole ROM ($0020000)
		lda #$00
		sta <target_loadaddress+0
		sta <target_loadaddress+1
		sta <target_loadaddress+3
		lda #$02
		sta <target_loadaddress+2

		jsr fs_readfileintomemory
		bcs loadedok

		; ROM not found: indicate which ROM we were looking for
		ldx #$0b
l17d:		lda txt_c65gsrom,x
		sta msg_romnotfound+19,x
		dex
		bne l17d
		ldx #<msg_romnotfound
		ldy #>msg_romnotfound
		jsr printmessage
		jsr sdwaitawhile
		jsr sdwaitawhile
		jsr sdwaitawhile
		jsr sdwaitawhile

		jmp sdcarderror
loadedok:

		lda file_sectorsread
		bne romfiletooshort
		lda file_sectorsread+1
		cmp #$00
		beq romfiletooshort
		cmp #$01
		bne romfiletoolong

		; need to store checksum
		jsr storeromsum
		
		; ROM file loaded, transfer control
		ldx #<msg_romok
		ldy #>msg_romok
		jsr printmessage
		jmp go64		

romfiletoolong:
		ldx #<msg_romfilelongerror
		ldy #>msg_romfilelongerror
		jsr printmessage
		ldz file_sectorsread+1
		jsr printhex
		ldz file_sectorsread
		jsr printhex
		jsr sdwaitawhile
		jmp reset_entry
romfiletooshort:
		ldx #<msg_romfileshorterror
		ldy #>msg_romfileshorterror
		jsr printmessage
		ldz file_sectorsread+1
		jsr printhex
		ldz file_sectorsread
		jsr printhex
		jsr sdwaitawhile
		jmp reset_entry

fileopenerror:
		ldx #<msg_fileopenerror
		ldy #>msg_fileopenerror
		jsr printmessage

sdcarderror:	ldx #<msg_sdcarderror
		ldy #>msg_sdcarderror
		jsr printmessage
		jsr sdwaitawhile
		jmp reset_entry

badfs:		ldx #<msg_badformat
		ldy #>msg_badformat
		jsr printmessage
		jsr sdwaitawhile
		jmp reset_entry
;;; ----------------------------------------------------------------------------
;;; FAT file system routines
;;; ----------------------------------------------------------------------------
toupper:	; convert ASCII character to upper case
		cmp #$60
		bcc tu1
		cmp #$7a
		bcs tu1
		and #$5f
tu1:		rts

fs_cd_rootdir:
		ldx #$00
cd1:		lda fs_rootdircluster,x
		sta fs_currentdircluster,x
		inx
		cpx #$04
		bne cd1
		sec
		rts

fs_opendir:
		; assume cluster for directory is already set
		ldx #$00
od1:		lda fs_currentdircluster,x
		sta fs_clusternumber,x
		inx
		cpx #$04
		bne od1
		lda #$00
		sta fs_direntrynumber
		jmp fs_openfile

fs_readdir:
		; read next entry from directory
		lda fs_direntrynumber
		cmp #$10

		bcc rd2

		; reached end of sector, so load next sector
		lda #$00
		sta fs_direntrynumber
		jsr fs_readnextsector
		; return with carry clear if we have readed the end of the directory
		bcs rd2
		rts

rd2:		; have sector, so can copy entry
		ldy #$00
		lda fs_direntrynumber
		and #$08
		bne rd3
		lda fs_direntrynumber
		asl
		asl
		asl
		asl
		asl
		tax
rd1:		lda $DE00,x
		sta fs_direntry,y
		inx
		iny
		cpy #$20
		bne rd1
rddone:		inc fs_direntrynumber
		sec		
		rts
rd3:		lda fs_direntrynumber
		asl
		asl
		asl
		asl
		asl
		tax
rd4:		lda $DF00,x
		sta fs_direntry,y
		inx
		iny
		cpy #$20
		bne rd4
		inc fs_direntrynumber
		sec
		rts		

fs_setfile:
		; get cluster from directory entry and store in cluster number
		lda fs_direntry+20
		sta fs_clusternumber+2
		lda fs_direntry+21
		sta fs_clusternumber+3
		lda fs_direntry+26
		sta fs_clusternumber+0
		lda fs_direntry+27
		sta fs_clusternumber+1
		sec
		rts		

fs_openfile:
		; zero sector number in cluster
		lda #$00
		sta fs_sector_in_cluster

		; Read first sector of first cluster
		; (no need to add fs_sector_in_cluster since it is zero here)
		jsr fs_clustertosector
		bcs of1
		rts
of1:		
		jsr sd_fix_sectornumber
		jmp sd_readsector

fs_readnextsector:
		; if switch 12 set, then indicate when we are looking for a sector
		lda $d6f1
		and #$10
		beq rs97
		ldx #<msg_lookingfornextsector
		ldy #>msg_lookingfornextsector
		jsr printmessage
		jsr sdwaitawhile
rs97:

		; load next sector of file
		jsr sd_inc_fixedsectornumber
		inc fs_sector_in_cluster
		lda fs_sector_in_cluster
		cmp fs_sectorspercluster
		bne rs6
		; need to advance cluster number
		lda #$00
		sta fs_sector_in_cluster
		jsr fs_getnextclusteroffile
		bcs rs5
		; end of file or other error
		rts
rs5:		; cluster number is right
		jsr fs_clustertosector
		jsr sd_fix_sectornumber
		php
		; display cluster number if switch 12 is set
		lda $d6f1
		and #$10
		beq rs98
		jsr printsectornumber
		jsr sdwaitawhile
rs98:		plp

rs6:		
		jmp sd_readsector

		.byte "ITS RIGHT HERE"

fs_getnextclusteroffile:
		; read chained cluster number for fs_clusternumber

		; FAT32 uses 32-bit cluster numbers.
		; 512 / 4 = 128 cluster numbers per sector.
		; To get the sector of the FAT containin a particular
		; cluster entry, we thus need to shift the cluster number
		; right 7 bits.  Then we add the start sector number of the FAT.

		; get cluster number into sector number registers
		ldx #$00
g1:		lda fs_clusternumber,x
		sta $D681,x
		inx
		cpx #$04
		bne g1

		; shift right 7 times
		ldy #$07
g31:		clc		
		ror $d684
		ror $d683
		ror $d682
		ror $d681
		dey
		bne g31

		; add start of partition offset
		ldx #$00
		clc
		php
g33:		plp
		lda $d681,x
		adc part_startsector,x
		sta $d681,x
		php
		inx
		cpx #$04
		bne g33
		plp

		; add start of fat offset
		ldx #$00
		clc
		php
g3:		plp
		lda $d681,x
		adc fs_startfat,x
		sta $d681,x
		php
		inx
		cpx #$04
		bne g3
		plp

		; turn sector number into byte address for non-SDHC cards
		jsr sd_fix_sectornumber

		; read FAT sector
		jsr sd_readsector
		bcc gfail

		; now read the right four bytes out.
		; cluster number needs to be shifted left 2 bits.
		; we only need the lowest order byte.
		lda fs_clusternumber
		asl
		asl
		tax
		ldy #$00
		lda fs_clusternumber
		and #$40
		bne ghigh
g6:		lda $de00,x
		sta fs_clusternumber,y
		inx
		iny
		cpy #$04
		bne g6
		bra gcheck
ghigh:		lda $df00,x
		sta fs_clusternumber,y
		inx
		iny
		cpy #$04
		bne ghigh
gcheck:		; check that resulting cluster number is valid.

		; First, only the lower 28-bits are valid
		lda fs_clusternumber+3
		and #$0f
		sta fs_clusternumber+3

		; Now check for special values:
		; cluster 0 is invalid
		lda fs_clusternumber+3
		ora fs_clusternumber+2
		ora fs_clusternumber+1
		ora fs_clusternumber
		cmp #$00
		beq gfail
		; $FFFFFF7 = bad cluster
		; $FFFFFFF = end of file
		lda fs_clusternumber+3
		cmp #$0f
		bne gok
		lda fs_clusternumber+2
		cmp #$ff
		bne gok
		lda fs_clusternumber+1
		cmp #$ff
		bne gok
		lda fs_clusternumber
		cmp #$ff
		beq gfail
		cmp #$f7
		beq gfail

gok:		; cluster number is okay
		sec
		rts

gfail:		
		clc
		rts
		

fs_clustertosector:
	; convert a cluster number in fs_clustertosector into a sector 
	; number loaded into $D681-$D684.

	  	; put cluster number into sector number	
		ldx #$03
l21:		lda fs_clusternumber,x
		sta $D681,x
		dex
		bpl l21

		; subtract number of reserved clusters
		ldx #$00
		sec
		php
l17:		plp
		lda $D681,x
		sbc fs_reservedclusters,x
		sta $D681,x
		php
		inx
		cpx #$04
		bne l17
		plp

		; now shift it left according to fs_sectorspercluster
		lda fs_sectorspercluster
		tay
		and #$fe
		beq multipliedclusternumber
l22:		clc
		rol $D681
		rol $D682
		rol $D683
		rol $D684
		tya
		lsr
		tay
		and #$fe
		bne l22
multipliedclusternumber:
		ldx #$00
mmm1:		lda $d681,x
		inx
		cpx #$04
		bne mmm1

		; skip over filesystem reserved and FAT sectors
		ldx #$00
		clc
		php
l23:		plp
		lda $D681,x
		adc fs_syssectors,x
		sta $D681,x
		php
		inx
		cpx #$04
		bne l23
		plp	

		; add start sector of partition
		ldx #$00
		clc
		php
l24:		plp
		lda $D681,x
		adc part_startsector,x
		sta $D681,x
		php
		inx
		cpx #$04
		bne l24
		plp
		
		; return success
		sec
		rts

printsectornumber:
		ldx #<msg_sectornumber
		ldy #>msg_sectornumber
		jsr printmessage
		ldy #$00
		ldx #$03
l19:		lda fs_clusternumber,x
		taz
		phx
		jsr printhex
		plx
		dex
		bpl l19
		ldx #$03
l20:		lda $D681,x
		taz
		phx
		jsr printhex
		plx
		dex
		bpl l20
		rts


fs_readfileintomemory:

		; Clear number of sectors read
		ldx #$00
		stx file_sectorsread
		stx file_sectorsread+1
		; Convert filename to upper case for comparison		
l17bb:		lda target_filename,x
		jsr toupper
		sta target_filename,x
		inx
		cpx #$0b
		bne l17bb

		; Now load root directory cluster.
		; (fs_clusternumber was set above)
		jsr fs_cd_rootdir
		jsr fs_opendir
		bcc sdcarderror

		; iterate through directory entries looking for ordinary file 
		; with matching name
nextdirectoryentry:
		jsr fs_readdir
		bcs l17e

		; End of directory, so return failure
		rts
l17e:

		ldx #$00
l17b:		lda fs_direntry,x
		jsr toupper
		cmp target_filename,x
		bne nextdirectoryentry
		inx
		cpx #$0b
		bne l17b
		; this is the entry

foundromfile:
		; get cluster number from directory entry.
		jsr fs_setfile
		bcc fileopenerror		
		jsr fs_openfile
		bcc fileopenerror

		lda #$00
		sta file_sectorsread
		sta file_sectorsread+1

		; Wait until switch 14 released before loading sector so that we
		; can intercept the routine to track down bugs
lr96:		
		lda $d6f1
		and #$40
		bne lr96

rf1:		
		; Write sector to address provided in target_loadaddress
		; (provided it is write-enabled!)

		; copy sector into 128KB fast RAM / ROM
		ldx #$00
		ldz #$00
rr1:		lda $de00,x
		nop ; 32-bit pointer access follows
		sta (<target_loadaddress),z
		inz
		inx
		bne rr1
		inw <target_loadaddress+1
rr1b:		lda $df00,x
		nop ; 32-bit pointer access follows
		sta (<target_loadaddress),z
		inz
		inx
		bne rr1b
		inw <target_loadaddress+1

		; see if there is another sector
		; (but don't try if we have read ~256KB already, since we are
		;  supposed to read 128KB only).
		inc file_sectorsread
		bne rf2
		inc file_sectorsread+1
rf2:		
		lda file_sectorsread+1
		
		jsr fs_readnextsector
		bcc notrf1
		jmp rf1
notrf1:
		; Read last sector, so return success.
		sec
		rts
		

;;; ----------------------------------------------------------------------------
;;; MBP / partition routines
;;; ----------------------------------------------------------------------------

; read master boot record. Does not sanity check anything.
readmbr:
		; begin by resetting SD card
		jsr sdreset
		bcs l7
		rts

l7:		ldx #<msg_foundsdcard
		ldy #>msg_foundsdcard
		jsr printmessage

		; MBR is sector 0	
		lda #$00
		sta $D681
		sta $d682
		sta $d683
		sta $d684

		jmp sd_readsector

;;; ----------------------------------------------------------------------------
;;; SD Card access routines
;;; ----------------------------------------------------------------------------
sdreset:
		; try SD-HC mode first
;		lda #$41
;		sta $D680
;		jsr sd_resetsequence
;		bcc sdr1
;		rts
sdr1:		; fall back to SD mode
		lda #$42
		sta $d680
		; fall through		

sd_resetsequence:
		; write $00 to $D680 to start reset
		lda #$00
		sta $D680
		jsr sdtimeoutreset
re1:		jsr sdreadytest
		bcs re1done	; success, so return
		bne re1		; not timed out, so keep trying
		rts 		; timeout, so return
re1done:	
		; write $01 to $D680 to complete reset
		lda #$01
		sta $D680
		jsr sdtimeoutreset
re2:		jsr sdreadytest
		bcs re2done	; success, so return
		bne re2		; not timed out, so keep trying
		rts 		; timeout, so return
re2done:
		; give card some time to settle after reset, otherwise 
		; reading sectors will fail
		jsr sdwaitawhile

		jsr sd_map_sectorbuffer

		; write $02 to $D680 to read MBR as a test of reset
		lda #$02
		sta $D680
		jsr sdtimeoutreset
		
re3:		; allow time for read to happen
		lda $d680
		jsr sdreadytest
		bcs redone	; success, so return
		bne re3		; not timed out, so keep trying
		; timeout -- so call reset again
		rts
redone:		
		sec
		rts

		
		; Watch for ethernet packets while waiting for the SD card.
		; this allows loading of code into the hypervisor for testing and
		; bare-metal operation.
sdwaitawhile:	jsr sdtimeoutreset

sw1:		
		inc $d020
		jsr checkethernet
		dec $d020

		inc $0300
		bne sw1
		inc $0301
		bne sw1
		inc $0302
		bne sw1
		rts

		; count to timeout value when trying to read from SD card
		; (if it is too short, the SD card won't reset)
sdtimeoutreset:
		lda #$00
		sta $0300
		sta $0301
		lda #$f7
		sta $0302
		rts

sdreadytest:	; check if SD card is ready, or if timeout has occurred
		; C is set if ready.
		; Z is set if timeout has occurred.
		lda $d680
		and #$03
		beq sdisready
		inc $0300
		bne sr1
		inc $0301
		bne sr1
		inc $0302
		bne sr1

		; timeout
		lda #$00 ; set Z

sr1:		clc
		rts
sdisready:	sec
		rts

sd_map_sectorbuffer:
		lda #$81
		sta $D680
		sec
		rts

sd_unmap_sectorbuffer:
		lda #$82
		sta $D680
		sec
		rts

sd_readsector:
		; Assumes fixed sector number (or byte address in case of SD cards)
		; is loaded into $D681 - $D684		

		; check if sd card is busy
		lda $d680
		and #$01
		bne rsbusyfail

		; try reading sector fast the first time
		jmp rs4

redoread:	
		; when retrying, introduce a delay.  This seems to be needed often
		; when reading the first sector after SD card reset.  
		ldx #$f0
		ldy #$00
		ldz #$00
r1:		inz
		bne r1
		iny
		bne r1
		inx
		bne r1

rs4:
		; ask for sector to be read
		lda #$02
		sta $d680

		; wait for sector to be read
		jsr sdtimeoutreset
rs3:		
		jsr sdreadytest
		bcs rsread
		bne rs3
		jmp rereadsector

rsread:
		lda $d680
		and #$01
		bne rs3

		; check that we read 512 bytes
		lda $d688
		lda $d689

		cmp #$02
		bne redoread

		sec
		rts

		; reset sd card and try again
rereadsector:
		jsr sdreset		
		jmp rs4

rsbusyfail:     ; fail
		clc 
		rts


printclusternumber:
		ldx #<msg_clusternumber
		ldy #>msg_clusternumber
		jsr printmessage
		ldy #$00
		ldz fs_clusternumber+3
		jsr printhex
		ldz fs_clusternumber+2
		jsr printhex
		ldz fs_clusternumber+1
		jsr printhex
		ldz fs_clusternumber+0
		jmp printhex

printsectoraddress:
		ldx #<msg_sectoraddress
		ldy #>msg_sectoraddress
		jsr printmessage
		ldy #$00
		ldz $D681+3
		jsr printhex
		ldz $D681+2
		jsr printhex
		ldz $D681+1
		jsr printhex
		ldz $D681+0
		jmp printhex

sd_inc_fixedsectornumber:
		; increment fixed sector number.
		; if SDHC, then increment is simple.
		; if SD, then we add $200
		lda $D680
		and #$10
		bne sdhc1
		; sd card mode: add $200
		lda $d682
		clc
		adc #$02
		sta $d682
		lda $d683
		adc #$00
		sta $d683
		lda $d684
		adc #$00
		sta $d684
		rts

sdhc1:		; SDHC card mode: add 1
		inc $d681
		bcc s1
		inc $d682
s2:		bcc s1
		inc $d683
		bcc s1
		inc $d684
s1:		
		rts

sd_fix_sectornumber:
		; assumes sector number has been loaded into 
		; $D681 - $D684
		; We need to check if the card is SDHC or SD.
		; If SD, we need to shift sector number left 9 bits,
		; as SD cards address by byte, not sector.
		; If card is SD, then shift it all left nine bits
		; We detect SD versus SDHC by reading whether SD controller is
		; in SDHC or SD mode.
		lda $D680
		and #$10
		beq sdcardmode
		; SDHC mode, so nothing to do
		rts
sdcardmode:     
		; shift left 8 bits first
		lda $D683
		sta $D684
		lda $D682
		sta $D683
		lda $D681
		sta $D682
		lda #$00
		sta $D681
		; now shift it all left one bit
		lda $D682
		asl
		sta $D682
		lda $D683
		rol
		sta $D683
		lda $D684
		rol
		sta $D684
		rts

;;; ----------------------------------------------------------------------------
;;; ROM loading and manipulation routines
;;; ----------------------------------------------------------------------------

checkromok:
		; read switch 13.  If set, assume ROM is invalid
		lda $d6f1
		and #$20
		bne checksumfails
		; or if loading a ROM other than C65GS.ROM, then assume ROM
		; is invalid
		lda txt_c65gsrom+5
		cmp #$20
		bne checksumfails
	
		; calculate checksum of loaded ROM ...
		jsr calcromsum
		; ... then fall through to testing it
testromsum:
		; have checksum for all slabs.

		jsr mapromchecksumrecord
		lda $4000
		cmp checksum
		bne checksumfails
		lda $4001
		cmp checksum+1
		bne checksumfails
		lda $4002
		cmp checksum+2
		bne checksumfails

		jsr resetmemmap

		sec
		rts

		; check failed
checksumfails:	clc
		rts

storeromsum:
		jsr mapromchecksumrecord
		lda checksum
		sta $4000
		lda checksum+1
		sta $4001
		lda checksum+2
		sta $4002
		rts

mapromchecksumrecord:
		; Map in ROM load record, and compare checksum
		; Here we have to use our extension to MAP to access >1MB
		; as only 128KB of slow ram is shadowed to $20000.
		; again, we have to take the relative nature of MAP, so
		; we ask for $FC000 to be mapped at $0000, which means that
		; $4000 will correspond to $0000 (MAP instruction address
		; space wraps around at the 1MB mark)
		
		; select 128MB mark for mapping lower 32KB of address space
		lda #$80
		ldx #$0f
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		; then map $FC000 + $4000 = $00000 at $4000-$7FFF
		lda #$c0
		ldx #$cf
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		eom
		
		rts

calcromsum:	; calculate checksum of 128KB ROM
		
		; use MAP to map C65 ROM address space in 16KB
		; slabs at $4000-$7FFF.  Check sum each, and
		; then compare checksum to ROM load record.
		; ROMs get loaded into slow RAM at $8020000-$803FFFF,
		; which is shadowed for reading using C65 MAP instruction to
		; C65 address space $20000-$3FFFF.
		; Checksum and ROM load record are stored in
		; $8000000 - $800FFFF, i.e., the first 64KB of
		; slow RAM.
		;
		; The 4510 MAP instruction does not normally provide access to the
		; full 28-bit address space, so we need to use a trick.
		; We do this by interpretting a MAP instruction that says to
		; map none of the 8KB pages, but provides an offset in the range
		; $F0000 - $FFF00 to set the "super page" register for that 32KB
		; moby to bits 8 to 15 of the offset.  In practice, this means
		; to allow mapping of memory above 1MB, the MB of memory being
		; selected is chosen by the contents of A and Y registers when 
		; X and Z = $0F.
		; 
				
		; reset checksum
		; checksum is not all zeroes, so that if RAM initialises with
		; all zeroes, including in the checksum field, the checksum will
		; not pass.
		lda #$03
		sta checksum
		sta checksum+1
		sta checksum+2
		sta checksum+3

		; start with bottom 16KB of ROM
		; we count in 16KB slabs, and ROM starts at 128KB mark,
		; so we want to check from the 8th to 15th slabs inclusive.
		lda #$08
		sta romslab

		; Summing can be done using normal use of MAP instruction,
		; since slow RAM is shadowed as ROM to $20000-$3FFFF

sumslab:	; romcheckslab indicates which 16KB piece.
		; MAP uses 256-byte granularity, so we need to shift left
		; 6 bits into A, and right 2 bits into X.
		; We then set the upper two bits in X to indicate that the mapping
		; applies to blocks 2 and 3.
		; BUT MAP is relative, and since we are mapping at the 16KB mark,
		; we need to subtract 1 lot of 16KB from the result.
		; this is easy -- we just sbc #$01 from romslab before using it.
		lda romslab
		sec 
		sbc #$01
		lsr
		lsr
		ora #$c0
		tax
		lda romslab
		sec
		sbc #$01
		asl
		asl
		asl
		asl
		asl
		asl
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		eom
		
		; sum contents of 16KB slab
		lda #$00
		sta <zptempv
		lda #$40
		sta <zptempv+1
		
sumpage:	ldy #$00
sumbyte:	lda checksum
		clc
		adc (<zptempv),y
		sta checksum
		bcc l6
		inc checksum+1
		bcc l6
		inc checksum+2
l6:		iny
		bne sumbyte
		inc <zptempv+1
		lda <zptempv+1
		cmp #$80
		bne sumpage
		
		inc romslab
		lda romslab
		cmp #$10
		bne sumslab

		jmp resetmemmap

;;; ----------------------------------------------------------------------------
;;; Display and basic IO routines
;;; ----------------------------------------------------------------------------

resetdisplay:
		; reset screen
		lda #$40
		sta $d030
		lda #$00
		sta $d031
		sta $D020
		sta $D021
		sta $D054
		; We use VIC-II style registers as this resets video frame in
		; least instructions, and 40 columns is fine for us.
		lda #$14
		sta $D018
		lda #$1B
		sta $D011
		lda #$C8
		sta $D016
		; point VIC-IV to bottom 16KB of display memory
		lda #$ff
		sta $DD01
		sta $DD00

		; Now switch to 16-bit text mode so that we can use proportional
		; characters and full-colour characters for chars >$FF for the logo
		lda #$05
		sta $d054
		; and 80 bytes (40 16-bit characters) per row.
		lda #<80
		sta $d040
		lda #>80
		sta $d041
		
		rts

resetpalette:
		; reset VIC-IV palette to sensible defaults.
		; load C64 colours into palette bank 3 for use when
		; PAL bit in $D030 is set.
		lda #$04
		sta $D030	; enable PAL bit in $D030
		lda #$ff
		sta $D070	; select palette bank 3 for display and edit

		; C64 colours designed to look like C65 colours on an
		; RGBI screen.
                lda #$00
                sta $D100
                sta $D200
                sta $D300
                lda #$ff
                sta $D101
                sta $D201
                sta $D301
                lda #$ba
                sta $D102
                lda #$13
                sta $D202
                lda #$62
                sta $D302
                lda #$66
                sta $D103
                lda #$ad
                sta $D203
                lda #$ff
                sta $D303
                lda #$bb
                sta $D104
                lda #$f3
                sta $D204
                lda #$8b
                sta $D304
                lda #$55
                sta $D105
                lda #$ec
                sta $D205
                lda #$85
                sta $D305
                lda #$d1
                sta $D106
                lda #$e0
                sta $D206
                lda #$79
                sta $D306
                lda #$ae
                sta $D107
                lda #$5f
                sta $D207
                lda #$c7
                sta $D307
                lda #$9b
                sta $D108
                lda #$47
                sta $D208
                lda #$81
                sta $D308
                lda #$87
                sta $D109
                lda #$37
                sta $D209
                lda #$00
                sta $D309
                lda #$dd
                sta $D10a
                lda #$39
                sta $D20a
                lda #$78
                sta $D30a
                lda #$b5
                sta $D10b
                sta $D20b
                sta $D30b
                lda #$b8
                sta $D10c
                sta $D20c
                sta $D30c
                lda #$0b
                sta $D10d
                lda #$4f
                sta $D20d
                lda #$ca
                sta $D30d
                lda #$aa
                sta $D10e
                lda #$d9
                sta $D20e
                lda #$fe
                sta $D30e
                lda #$8b
                sta $D10f
                sta $D20f
                sta $D30f

		; put a colour cube in other entries
		ldx #$10
paletteloop:
		; R = upper 3 bits
		txa
		lsr
		lsr
		lsr
		and #$0e
		sta $d100,x

		; G = next 3 bits
		txa
		lsr
		and #$0e
		sta $d200,x
		
		; B = lowest 2 bits
		txa
		asl
		asl
		and #$0c
		sta $d300,x

		inx
		bne paletteloop

		rts

; erase standard 40-column screen
erasescreen:
		; bank in 2nd KB of colour RAM
		lda #$01
		tsb $D030

		; use DMA to clear screen and colour RAM
		; The screen is in 16-bit bit mode, so we actually need to fill
		; with $20,$00, ...
		; We will cheat by setting the first four bytes, and then copying from
		; there, and it will then read from the freshly written bytes.
		; (two bytes might not be enough to allow the write from the last DMA
		;  action to be avaialble for reading because of how the DMAgic is
		;  pipelined).
		lda #$20
		sta $0400
		sta $0402
		lda #$00
		sta $0401
		sta $0403
		
		; Set bottom 22 bits of DMA list address as for C65
		; (8MB address range)
		lda #$ff
		sta $d702
		; Kickstart ROM is at $FFFE000 - $FFFFFFF, so
		; we need to tell DMAgic that DMA list is in $FFxxxxx.
		; this has to be done AFTER writing to $d702, as $d702
		; clears bits 27 - 22 of the DMA list address to help with
		; compatibility.
		lda #$ff
		sta $d704
		; copy from MB $00 for screen clearing
		lda #$00
		sta $d705
		; destination MB is $00, since we are writing to C64 RAM space.
		lda #$00
		sta $d706

		lda #>erasescreendmalist
		sta $d701
		; set bottom 8 bits of address and trigger DMA.
		lda #<erasescreendmalist
		sta $d700

		; Kickstart ROM is at $FFFE000 - $FFFFFFF, so
		; we need to tell DMAgic that DMA list is in $FFxxxxx.
		; this has to be done AFTER writing to $d702, as $d702
		; clears bits 27 - 22 of the DMA list address to help with
		; compatibility.
		lda #$ff
		sta $d704
		; similarly we need to tell DMAgic that we are copying data from
		; MB $FF (this is for copying the disk chooser)
		sta $d705
		; destination MB is $00, since we are writing to C64 RAM space.
		lda #$00
		sta $d706

		lda #>copydiskchooserdmalist
		sta $d701
		; set bottom 8 bits of address and trigger DMA.
		lda #<copydiskchooserdmalist
		sta $d700

		; clear source/destination MB so that C65 ROM doesn't go bananas
		lda #$00
		sta $d705

		; bank 2nd KB of colour RAM back out
		lda #$01
		trb $D030

		; move cursor back to top of the screen
		; (but leave 8 rows for logo and banner text)
		lda #$08
		sta screenrow

		; draw 8x8 char block for logo
		ldx #$00
		ldy #$00
logo1:		txa
		sta $0400+[80*0],y
		ora #$08
		sta $0400+[80*1],y
		txa
		ora #$10
		sta $0400+[80*2],y
		txa
		ora #$18
		sta $0400+[80*3],y
		txa
		ora #$20
		sta $0400+[80*4],y
		txa
		ora #$28
		sta $0400+[80*5],y
		txa
		ora #$30
		sta $0400+[80*6],y
		txa
		ora #$38
		sta $0400+[80*7],y
		iny
		iny
		inx
		cpx #$08		
		bne logo1
		; then write the high bytes for these (all $01, so char range will be
		; $100-$140. $100 x $40 = $4000-$4FFF
		ldx #$00
		lda #$01
logo2:		sta $0401+[80*0],x
		sta $0401+[80*1],x
		sta $0401+[80*2],x
		sta $0401+[80*3],x
		sta $0401+[80*4],x
		sta $0401+[80*5],x
		sta $0401+[80*6],x
		sta $0401+[80*7],x
		inx
		inx
		cpx #$10
		bne logo2

		; finally work around the VIC-IV bug where the first normal character
		; following a full-colour character gets skipped by inserting early
		; end of line terminator markers on the lines. Without this, the first
		; character of the next line would show
		lda #$ff
		sta $044e
		sta $044f
		sta $049e
		sta $049f
		sta $04ee
		sta $04ef
		sta $053e
		sta $053f
		sta $058e
		sta $058f
		sta $05de
		sta $05df
		sta $062e
		sta $062f
		sta $067e
		sta $067f

		rts

erasescreendmalist:
		; Clear screen RAM
		.byte $04 ; COPY + chained request
		.word 1996 ; 40x25x2-4 = 1996
		.word $0400 ; copy from start of screen at $0400
		.byte $00 ; source bank 00
		.word $0404 ; ... to screen at $0402
		.byte $00   ; screen is in bank $00
		.word $0000 ; modulo (unused)
		; Clear colour RAM
		.byte $07 ; fill + chained request
		.word 2000 ; 40x25x2 = 2000
		.byte $01 ; fill with white = $01
		.byte $00,$00 ; rest of source address is ignored in fill
		.word $d800 ; screen is at $0400
		.byte $80   ; screen is in IO, so bank IO in to DMA context
		.word $0000 ; modulo (unused)
		; Clear $4000-$4FFF (for logo display) 
		.byte $03 ; fill + last request
		.word $1000 ; 64x64 = $1000
		.byte $00 ; fill with black = $00
		.byte $00,$00 ; rest of source address is ignored in fill
		.word $4000 ; logo sits at $4000
		.byte $00   ; ... in bottom half of chipram, so bank $00
		.word $0000 ; modulo (unused)

copydiskchooserdmalist:
		; also copy diskchooser from $FFFE000-$FFFEFFF to $000C000-$000CFFF
		.byte $00 ; copy + last request in chain
		.word $1000
		.word diskchooserstart ; source address 
		.byte $0F ; source bank
		.word $c000 ; destination address
		.byte $00   ; destination bank
		.word $0000 ; modulo (unused)

checkpoint:
		pha
		ldx #<msg_checkpoint
		ldy #>msg_checkpoint
		jsr printmessage
		ldy #$00
		plz
		jmp printhex

printmessage:
		stx <zptempp
		sty <zptempp+1
		lda #$00
		sta <zptempp2
		lda #$04
		sta <zptempp2+1
		ldx screenrow

		; if we have reached the bottom of the screen, start writing again
		; from the top of the screen (but don't touch the top 8 rows for
		; logo and banner)
		cpx #25
		bne pm2
		ldx #$08
		stx screenrow

		; work out the screen address
pm2:		cpx #$00
		beq pm1
		clc
		lda <zptempp2
		adc #$50          ; 40 columns x 16 bit
		sta <zptempp2
		lda <zptempp2+1
		adc #$00
		sta <zptempp2+1
		; if reached bottom of screen, then loop back to top of screen
		cmp #$0b
		bcc pm5
		lda <zptempp2
		cmp #$d0
		bcc pm5
	
		lda #$80
		sta <zptempp2
		lda #$06
		sta <zptempp2+1
pm5:		dex
		bne pm2
pm1:

		; Clear line (16-bit chars, so write #$0020 to each word
		ldy #$00
pm1b:		lda #$20
		sta (<zptempp2),y
		iny
		lda #$00
		sta (<zptempp2),y		
		iny
		cpy #$50
		bne pm1b		

writestring:
		phz
		ldy #$00
		ldz #$00
pm3:		lda (<zptempp),y
		beq endofmessage
		; convert ASCII/PETSCII to screen codes
		cmp #$40
		bcc pm4
		and #$1f
pm4:		; write 16-bit character code
		sta (<zptempp2),z
		inz
		pha
		lda #$00
		sta (<zptempp2),z
		pla
		iny
		inz
		bne pm3
endofmessage:
		inc screenrow

		plz
		rts

printbanner:
		stx <zptempp
		sty <zptempp+1
		lda #<$0504
		sta zptempp2
		lda #>$0504
		sta zptempp2+1
		jsr writestring
		dec screenrow
		rts
		
printhex:	
		; output contents of Z on last written screen line
		tza
		lsr
		lsr
		lsr
		lsr
		jsr printhexdigit		
		tza
		and #$0f
printhexdigit:
		; find next $ sign to replace with hex digit
		tax
phd3:		lda (<zptempp2),y
		cmp #$24
		beq phd2
		iny
		iny
		cpy #$50
		bne phd3
		rts
phd2:		txa

		ora #$30
		cmp #$3a
		bcc phd1
		sbc #$39
phd1:		sta (<zptempp2),y
		iny
		iny
		rts

; Transfer control to C64 kernel.
; (This also allows entry to C65 mode, because the
;  C64-mode kernel on the C65 checks if C65 mode
;  should be entered.)
go64:
		; Check if hold boot switch is set (switch 15)?
		lda $d6f1
		bpl l42      ; no, so continue		

		; yes, display message
		ldx #<msg_releasesw15
		ldy #>msg_releasesw15
		jsr printmessage

l41:		lda $d6f1
		bmi l41
l42:

		; unmap sector buffer so C64 can see CIAs
		lda #$82
		sta $D680

		; copy routine to stack to switch to
		; C64 memory map and enter via reset
		; vector.  
	
		; erase kickstart ROM copy from RAM
		; (well, at least enough so that BASIC doesn't get upset)
		; XXX - use DMA
		ldx #$00
		txa
g61:		sta $0800,x
		inx
		bne g61		

		; reset video mode to normal
		lda #$00
		sta $d054
		lda #<40
		sta $d040
		lda #>40
		sta $d041


		jsr task_set_c64_memorymap
		jsr task_set_pc_to_reset_vector

		; Exit hypervisor and transfer control to ROM
		sta hypervisor_enterexit_trigger
	
longpeek:
		; Use DMAgic to read any byte of RAM in 28bit address space.
		; Value gets read into $BC00 (kickstart_scratchbyte0)
		; ($FFFBC00 - $FFFBDFF)

		; Patch DMA list
		sta $d705 ; DMAgic source MB
		lda #$ff
		sta $d706 ; DMAgic destination MB
		stx longpeekdmalist+3
		sty longpeekdmalist+4
		stz longpeekdmalist+5
		; Set DMA list address
		lda #>longpeekdmalist
		sta $d701
		lda #$0f
		sta $d702 ; DMA list address is $xxFxxxx
		lda #$ff
		sta $d704 ; DMA list address is $FFxxxxx
		; set bottom bits of DMA list address and trigger DMA
		lda #<longpeekdmalist
		sta $d700
		rts

longpeekdmalist:
		.byte $00 ; COPY, no chain
 		; 1 byte
		.word $0001
		; source address
		.word $0000
		.byte $00
		; destination address ($xxFBC00)
		.word kickstart_scratchbyte0
		.byte $0F 
		.byte $00,00 ; Modulo
		
; reset memory map to default
resetmemmap:
		; clear memory MAP MB offset register
		lda #$00
		ldx #$0f
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		; and clear all mapping
		tax
		ldy #$00   ; keep kickstart mapped at $8000-$BFFF
		ldz #$3f
		map
		eom
		rts


; If C=1, enable enhanced IO bank, else return to
; C64 standard IO map.
enhanced_io:
		bcs l1
		; Return to VIC-II / C64 IO
		lda #$00
		sta VICIV_MAGIC
		rts
l1:		; Enable VIC-IV / C65GS IO
		lda #$47
		sta VICIV_MAGIC
		lda #$53
		sta VICIV_MAGIC
		RTS

; Check for digits 0 - 9 on keyboard, and change which ROM we intend to read
; based on that.
keyboardread:
		lda #$ff
		sta $dc03
		lda #$00
		sta $dc02
		lda #$fe
		sta $dc01
		lda #$20
		ldx $dc00
		cpx #$7f
		bne k1
		lda #$31
k1:		cpx #$ef
		bne k9
		lda #$39
k9:		cpx #$f7
		bne k7
		lda #$37
k7:		cpx #$fb
		bne k5
		lda #$35
k5:		cpx #$fd
		bne k3
		lda #$33
k3:		ldx #$f7
		stx $dc01
		ldx $dc00
		cpx #$7f
		bne k0
		lda #$32
k0:		cpx #$ef
		bne k8
		lda #$30
k8:		cpx #$f7
		bne k6
		lda #$38
k6:		cpx #$fb
		bne k4
		lda #$36
k4:		cpx #$fd
		bne k2
		lda #$34
k2:		
		; put character into 6th byte position of ROM file name.
		; so no key looks for C65GS.ROM, where as 0-9 will look
		; for C65GSx.ROM, where x is the number.
		sta txt_c65gsrom+5
		rts

;-----------------------------------------------------------------------------
	; This is an adaption of the etherload code, to allow loading of memory
	; while waiting at the kickstart ROM.  Since this is an amazing security
	; hole, we only do it if switch 8 is set.

setupethernet:
	; only do it if switch 8 is on
	lda $d6f1
	and #$01
	bne e1
	rts
e1:
	; C65GS io
	lda #$47
	sta viciv_magic
	lda #$53
	sta viciv_magic

	; Map ethernet registers at $6000 - $7FFF
	
	; Ethernet controller really lives $FFDE000 - $FFDEFFF, so select $FF megabyte section for MAP LO
	lda #$ff
	ldx #$0f
	ldy #$00   ; keep kickstart mapped at $8000-$BFFF
	ldz #$3f
	map
	eom

	; now enable mapping of $DE000-$DFFFF at $6000
	; MAPs are offset based, so we need to subtract $6000 from the target address
	; $DE000 - $6000 = $D8000
	lda #$80
	ldx #$8d
	ldy #$00   ; keep kickstart mapped at $8000-$BFFF
	ldz #$3f
	map
	eom

	; Ethernet registers should now be visible from $6000 - $6FFF
	; read buffer will be at $6800 - $6FFF
	; length of frame is in $6FFE / $6FFF in little-endian byte order
	; so LDA $6FFE ; LDX $6FFF ; jsr $BDCD should print packet length to screen

	; make sure ethernet transceiver is on and not generating IRQs
	; (we will poll it).
	; also make sure that we acknowledge the last received packet so that the
	; ethernet controller knows it can receive.
	lda $d6e1
	lsr
	and #$02
	ora #$01
	sta $d6e1

	rts

checkethernet:
	; only do it if switch 8 is on
	lda $d6f1
	and #$01
	bne e2
	rts
e2:

	lda $d6e1
	and #$20
	bne gotpacket
	rts
gotpacket:
	; clear eth RX signal, and leave ethernet tranceiver on
	; and make last used RX buffer visible
	lda $d6e1
	and #$04
	lsr
	ora #$01
	sta $d6e1


	; Got a packet.
	; check whether it is UDP port 4510
	; or whether it is an ARP request

	; Here we want to check that $680E - $6817 =
	; 08 06 00 01 08 00 06 04 00 01

	ldx #$09
arploop0:
	lda $680e,x
	cmp arptemplate,x
	bne notarp
	dex
	bpl arploop0

	; check that IP address asked for ends in .65
	lda $682b
	cmp #65
	bne notarp

	; ok, so we have an ARP request.
	; now we need to build the ARP reply and send it.
	; We should copy the sender's 

	; XXX for now just increment border colour

	; set output packet size
	; 6+6+2 bytes ethernet header + 28 bytes of ARP reply = 42
	lda #<42
	sta $d6e2
	lda #>42
	sta $d6e3

	; copy fixed ARP fields (we will overwrite some later)
	; (note that TX buffer lacks 2 byte RX buffer header)
	ldx #$14
arploop1:
	lda $6802,x
	sta $6800,x
	dex
	bpl arploop1
	; Copy ethernet source to ethernet destination in TX buffer
	; Set our mac address in ethernet source address field in TX buffer
	ldx #$05
arploop2:
	lda $6808,x    ; requestors mac from RX ethernet header
	sta $6800,x    ; requestors mac into TX ethernet header
	lda #$40
	sta $6806,x    ; our mac in ethernet header
	sta $6816,x    ; our mac in ARP payload
	dex
	bpl arploop2
	; set packet as ARP reply
	lda #$02     ; $02 = reply, $01 = request
	sta $6815

	ldx #$03
	; copy requested IP address into reply IP address field
arploop3:
	lda $6828,x
	sta $681c,x
	dex
	bpl arploop3
	; copy requestors MAC+IP into target MAC+IP fields
	ldx #9
arploop4:
	lda $6818,x
	sta $6820,x
	dex
	bpl arploop4
	
	; packet should now all be ready - hit TX button
	lda #$01
	sta $d6e4
notarp:

	; is it IPv4?
	lda $6810
	cmp #$45
	bne badpacket
	; is it UDP?
	lda $6819
	cmp #$11
	bne badpacket
	; UDP port #4510
	lda $6826
	cmp #>4511
	bne badpacket
	lda $6827
	cmp #<4511
	bne badpacket

	; packet body begins at $0444 / $682C.
	; if it begins with $A9 = LDA immediate, then jsr to the packet body.
	; packet body can do whatever is required to load data, keeping this
	; programme very simple.
	lda $682c
	cmp #$a9
	bne badpacket
	jsr $682C

badpacket:
	rts

arptemplate:
	.byte $08,$06,$00,$01,$08,$00,$06,$04,$00,$01

; messages.  All have to be 40 bytes long
msg_kickstart:        .byte "C65GS KICKSTART V00.03",0
msg_romok:            .byte "ROM CHECKSUM OK - BOOTING",0
msg_rombad:	      .byte "ROM CHECKSUM FAIL - LOADING ROM",0
msg_charrombad:	      .byte "COULD NOT LOAD CHARROM.G65",0
msg_charromloaded:    .byte "LOADED CHARROM.G65 ($$$$ SECTORS)",0
msg_tryingsdcard:     .byte "LOOKING FOR SDCARD...",0
msg_foundsdcard:      .byte "FOUND AND RESET SDCARD",0
msg_sdcarderror:      .byte "ERROR READING FROM SD CARD",0
msg_badformat:	      .byte "BAD MBR OR DOS BOOT SECTOR.",0
msg_sdcardfound:      .byte "READ PARTITION TABLE FROM SDCARD",0
msg_partitiondetails: .byte "PARTITION 1($$) @$$$$$$$$, SIZE $$$$$$$$",0
msg_fsdetails: 	      .byte " FS SPC:$$ RSVSEC:$$$$ RSVCLUS:$$$$$$$$",0
msg_reservedsectors:  .byte " SYS:$$$$$$$$ DAT:$$$$$$$$ CLUS:$$$$$$$$",0
msg_sectornumber:     .byte " CLUSTER:$$$$$$$$ -> SECTOR:$$$$$$$$",0
msg_foundromfile:     .byte "FOUND ROM FILE. START CLUSTER = $$$$$$$$",0
msg_fileopenerror:    .byte "COULD NOT OPEN ROM FILE FOR READING",0
msg_readingfile:      .BYTE "READING ROM FILE...",0
msg_romfilelongerror: .byte "ROM TOO LONG: (READ $$$$ SECTORS)",0
msg_romfileshorterror:.byte "ROM TOO SHORT: (READ $$$$ SECTORS)",0
msg_clusternumber:    .byte " NEXT CLUSTER=$$$$$$$$",0
msg_sectoraddress:    .byte " NEXT SECTOR=$$$$$$$$",0
msg_checkpoint:	      .byte " CHECKPOINT $$ $$ $$ $$ $$ $$ $$ $$ $$",0
msg_nod81:	      .byte "CANNOT FIND C65GS.D81 - BOOTING DISKLESS",0
msg_foundd81:	      .byte "MOUNTING C65GS.D81 @ INTERNAL F011 DRIVE",0
msg_d81wronglength:   .byte "FAIL: C64GS.D81 IS NOT 819200 BYTES LONG",0
msg_d81fragged:       .byte "FAIL: C65GS.D81 IS FRAGMENTED: DEFRAG IT",0
msg_d81mounted:	      .byte "C65GS.D81 SUCCESSFULLY MOUNTED",0
msg_releasesw15:      .byte "RELEASE SW15 TO CONTINUE BOOTING.",0
msg_romnotfound:      .byte "COULD NOT FIND ROM C65GSXXXROM",0
msg_foundkickup:      .byte "LOADING KICKUP.G65 INTO HYPERVISOR",0
msg_nokickup:         .byte "NO KICKUP.G65 TO LOAD (OR BROKEN)",0
msg_kickuploaded:     .byte "KICKUP LOADED TO 00004000 - $$$$$$$$",0
msg_alreadykicked:    .byte "RUNNING KICKED HYPERVISOR",0
msg_etherkick:	      .byte "BOOTING VIA ETHERKICK: UDP PORT 4511",0
msg_lookingfornextsector:
		      .byte "LOOKING FOR NEXT SECTOR OF FILE",0
msg_nologo:	      .byte "COULD NOT LOAD BOOTLOGO.G65",0
msg_blankline:	      .byte 0

; filename of character ROM
txt_c65gscharrom:     .byte "CHARROM G65"
; filename of ROM we want to load in FAT directory format
txt_c65gsrom:	      .byte "C65GS   ROM"
; filename of 1581 disk image we mount by default
txt_c65gsd81:	      .byte "C65GS   D81"
; filename of kickstart update file
txt_kickupfile:	      .byte "KICKUP  G65"
; filename containing boot logo
txt_bootlogo:	      .byte "BOOTLOGOG65"

diskchooserstart:
	.incbin "diskchooser"
diskchooserend:

		.checkpc $BB00
		.advance $BB00

; Table of available disks.
; This includes native FAT32 disks, as well as (in the future at least)
; mounted .D41, .D71, .D81 and .DHD files using Commodore DOS filesystems.
; But for now, we are supporting only FAT32 as the filesystem.
; See kickstart_dos.a65 for information on how the table is used.
; Entries are 32 bytes long, so we can have 8 of them.
dos_disk_table:
		

		; Hypervisor scratch pad aat $BC00-$BDFF

		.checkpc $BC00
		.advance $BC00

kickstart_scratchbyte0:
		.byte $00		

; The number of disks we have
dos_disk_count:
		.byte $00
; The default disk
dos_default_disk:
		.byte $00
; The current disk
dos_disk_current_disk:
		.byte $00
; The offset of the entry in dos_disk_table for the current disk
dos_disk_table_offset:
		.byte $00
; For providing feedback on why DOS calls have failed
dos_error_code:
		.byte $00

		.checkpc $BD00
		.advance $BD00,$00
		.include "kickstart_process_descriptor.a65"

		; Kickstart stack (8-bit)
		.checkpc $BE00
		.advance $BE00,$3d

		; Kickstart ZP at $BF00-$BFFF
		.checkpc $BF00
		.advance $BF00,$3e
; Temporary vector storage for DOS
dos_scratch_vector: .word 0,0
; general kickstart temporary variables
zptempv:	    .word 0
zptempv2:	    .word 0
zptempp: 	    .word 0
zptempp2: 	    .word 0
zptempv32:	    .word 0,0
zptempv32b:	    .word 0,0
target_loadaddress: .word 0,0
target_filename:    .byte "12345678ABC"

		.checkpc $C000
		.advance $C000, $3f

		 .outfile "kickstart65gs.bin"