; C65GS Kick Start ROM.
; Paul Gardner-Stephen, 2014.
;
; Purpose: 
; 1. Verify checksum of ROM area of slow RAM.
; 1. If checksum fails, load complete ROM from SD card.
; 2. Select default disk image for F011 emulation.
;
; The kickstart ROM is 8KB in length, and maps at $E000-$FFFF
; essentially the same as the C64 kernel.
;
; Kickstart modifies RAM from $0000-$07FF (ZP, stack, 40-column
; screen) during normal boot.
;
; If Kickstart needs to load the ROM from SD card, then it may
; modify the first 64KB of fast ram.
;
; We will use the convention of C=0 means failure, and C=1 means
; success.
;

; scratch space in ZP space usually used by kernel
	.data 
	.org $0080
	.space zptempv 2
	.space zptempv2 2
	.space romslab 1
	.space timerticks 1
	.space timerlimit 1
	.space screenrow 1

	.org $0200
	.space checksum 4
	.space rom_sectorsread 2
	

	; structure for partition table
	.space part_startsector 4

	; structure for FAT32 file system
	.space fs_startfat 4
	.space fs_syssectors 4
	.space fs_reservedclusters 4
	.space fs_rootdircluster 4
	.space fs_datasectors 4
	.space fs_clustercount 4
	.space fs_sectorspercluster 1

	; structure for current directory entry
	.space fs_currentdircluster 4
	.space fs_direntry 32
	.space fs_direntrynumber 1
	; structure for current open file
	.space fs_clusternumber 4
	.space fs_sector_in_cluster 1

	.text

	; sdcard access routines sit in the first 4KB of the ROM,
	; and get copied down to $1000-$1FFF so that they can be run
	; from chipram instead of IO space, since there are problems with
	; code in fastio space accessing 

	; Routines for SD card access in kickstart ROM.
	; These routines are copied into RAM to work around bugs that prevent
	; reliable access to the sdcard from the kickstart ROM, being hosted on
	; fastio as it is.  Of course, it would be nice to fix the primary bug.

	.org $1000



kickstart_entry:
		; We DO NOT need to mess with $01, because
		; the 4510 starts up with kickstart mapped at $E000, 
		; standard ($FFD0xxx) IO page mapped at $D000,
		; and fast RAM elsewhere.  So we just need to key $D02F
		; to get enhanced io
		sec
		jsr enhanced_io

		jsr resetdisplay
		jsr resetpalette
		jsr erasescreen

		; display welcome screen
		ldx #<msg_kickstart
		ldy #>msg_kickstart
		jsr printmessage
		inc screenrow

		; Check state of current ROM
		jsr checkromok
		bcc loadrom

		; ROM is loaded and ready, so transfer control
		; to it.
		ldx #<msg_romok
		ldy #>msg_romok
		jsr printmessage
		jmp go64

loadrom:	; ROM is not loaded, so try to load it, or prompt
		; for user to insert SD card
		ldx #<msg_rombad
		ldy #>msg_rombad
		jsr printmessage

		; Try to read the MBR from the SD card
		ldx #<msg_tryingsdcard
		ldy #>msg_tryingsdcard
		jsr printmessage
tryreadmbr:
		jsr readmbr
		bcs gotmbr

		jmp tryreadmbr
		
gotmbr:
		ldx #<msg_sdcardfound
		ldy #>msg_sdcardfound
		jsr printmessage
		; got master boot record
		lda #$3e           ; ">" character
		sta $07c0          ; $0400+(24*40)

		jsr sdmapsectorbuffer

		; check for $55AA MBR signature
		lda $DFFE
		cmp #$55
		bne badfs
		lda $DFFF
		cmp #$AA
		bne badfs

		; read partition 1 details from $DFBE
		; $DFBE - $80 = bootable, $00 = inactive.  We ignore this
		; $DFC2 - Partition type
		; $DFC6 - Starting SECTOR number
		; $DFCA - Number of sectors in partition
		ldx #<msg_partitiondetails
		ldy #>msg_partitiondetails
		jsr printmessage
		; overwrite $ chars in template with hex digits
		ldy #$00
		ldz $DFC2
		jsr printhex
		ldz $DFC9
		stz part_startsector+3
		jsr printhex
		ldz $DFC8
		stz part_startsector+2
		jsr printhex
		ldz $DFC7
		stz part_startsector+1
		jsr printhex
		ldz $DFC6
		stz part_startsector+0
		jsr printhex
		ldz $DFCD
		jsr printhex
		ldz $DFCC
		jsr printhex
		ldz $DFCB
		jsr printhex
		ldz $DFCA
		jsr printhex

		; load start sector of partition into SD card sector register
		ldx #$03
l9:		lda part_startsector,x
		sta $D681,x
		dex
		bpl l9
		jsr sd_fix_sectornumber
		jsr sd_readsector
		bcc sdcarderror		

		; MILESTONE: Have boot sector of file system
		lda #$3e           ; ">" character
		sta $07c1          ; $0400+(24*40)+1
	
		lda $DFFE
		cmp #$55
		bne badfs
		lda $DFFF
		cmp #$AA
		bne badfs

		; report file system info
		ldx #<msg_fsdetails
		ldy #>msg_fsdetails
		jsr printmessage			

		; sectors per cluster
		ldy #$00
		ldz $DE0D
		jsr printhex
		; reserved sectors
		ldz $DE0F
		jsr printhex
		ldz $DE0E
		jsr printhex
		; first cluster
		ldz $DE00+47
		jsr printhex
		ldz $DE00+46
		jsr printhex
		ldz $DE00+45
		jsr printhex
		ldz $DE00+44
		jsr printhex

		; The information of relevance we have now is:
		; $DE0D - sectors per cluster
		; $DE0E-$DE0F - reserved sectors
		; $DE10 - number of copies of FAT
		; $DE11 - Root dir entry count (0 on FAT32)
		; $DE20-$DE23 - number of sectors in the file system
		; $DE24-$DE27 - number of sectors in one copy of the FAT
		; $DE2C-$DE2F - number of reserved clusters
		
		; We need to work out if this is a FAT32 partition by working out
		; the number of clusters.  To work that out, we need to work out
		; the number of data sectors.  To work that out, we need to work out
		; the number of reserved sectors.
		
		; first, filter out obviously FAT16/FAT12 file systems
		lda $DE11
		bne badfs

		; With root directory entries = 0, the reserved sector count
		; is the number of reserved sectors, plus (copies of fat) *
		; (sectors in one copy of the fat).
		; the first FAT begins immediately after the reserved sectors
		ldx #$03
l11:		lda $DE0E,x
		sta fs_syssectors,x
		sta fs_startfat,x
		lda $DE2C,x
		sta fs_reservedclusters,x
		dex
		bpl l11
		lda #$00
		sta fs_syssectors+2
		sta fs_syssectors+3
		sta fs_startfat+2
		sta fs_startfat+3
		ldy $DE10
		beq addedfatsectors
addnextfatsectors:
		ldx #$00
		clc
		php
l12:		plp
		lda fs_syssectors,x
		adc $DE24,x
		sta fs_syssectors,x
		php
		inx
		cpx #$04
		bne l12
		plp
		dey
		bne addnextfatsectors
addedfatsectors:

		; also calculate number of data sectors
		sec
		ldx #$03
l13:		lda $DE20,x
		sbc fs_syssectors,x
		sta fs_datasectors,x
		sta fs_clustercount,x
		dex
		bpl l13		

		; from number of data sectors and sectors per cluster,
		; we can work out the number of clusters.
		lda $DE0D
		sta fs_sectorspercluster
		tay
		and #$fe
		beq gotclustercount
l14:
		ldx #$03
		clc
l15:		lda fs_clustercount,x
		ror
		sta fs_clustercount,x
		dex
		bpl l15
		tya
		lsr
		tay
		and #$fe
		bne l14
gotclustercount:

		; filter out non-FAT32 filesystems
		; NOTE: FAT32 can have as few as 65525 clusters, but we do not support
		; such file systems, which should be rare, anyway.
		lda fs_clustercount+3
		ora fs_clustercount+2
		beq badfs

		ldx #<msg_reservedsectors
		ldy #>msg_reservedsectors		
		jsr printmessage
		ldy #$00
		ldz fs_syssectors+3
		jsr printhex
		ldz fs_syssectors+2
		jsr printhex
		ldz fs_syssectors+1
		jsr printhex
		ldz fs_syssectors+0
		jsr printhex

		ldz fs_datasectors+3
		jsr printhex
		ldz fs_datasectors+2
		jsr printhex
		ldz fs_datasectors+1
		jsr printhex
		ldz fs_datasectors+0
		jsr printhex

		ldz fs_clustercount+3
		jsr printhex
		ldz fs_clustercount+2
		jsr printhex
		ldz fs_clustercount+1
		jsr printhex
		ldz fs_clustercount+0
		jsr printhex
	
		; Store cluster number of root directory
		ldx #$03
l16:		lda $DE2C,x
		sta fs_rootdircluster,x
		sta fs_clusternumber,x
		dex
		bpl l16

		; MILESTONE: Have file system properties.
		lda #$3e           ; ">" character
		sta $07c2          ; $0400+(24*40)+2

		; Now load root directory cluster.
		; (fs_clusternumber was set above)
		jsr fs_cd_rootdir
		jsr fs_opendir
		bcc sdcarderror

		; iterate through directory entries looking for ordinary file 
		; C65GS.ROM
nextdirectoryentry:
		jsr fs_readdir
		bcc sdcarderror


		ldx #$00
l17b:		lda fs_direntry,x
		jsr toupper
		cmp txt_c65gsrom,x
		bne nextdirectoryentry
		inx
		cpx #$0b
		bne l17b
		; this is the entry
		jmp foundromfile

foundromfile:
		; get cluster number from directory entry.
		jsr fs_setfile

		; MILESTONE: Have file system properties.
		lda #$3e           ; ">" character
		sta $07c3          ; $0400+(24*40)+3

		ldx #<msg_foundromfile
		ldy #>msg_foundromfile
		jsr printmessage
		ldy #$00
		ldz fs_clusternumber+3
		jsr printhex
		ldz fs_clusternumber+2
		jsr printhex
		ldz fs_clusternumber+1
		jsr printhex
		ldz fs_clusternumber+0
		jsr printhex
		
		; now read the ROM file
		; start by setting MAP MB register to zero
		lda #$00
		ldx #$0f
		ldy #$00
		ldz #$0f
		map
		eom

		lda #$00
		sta rom_sectorsread
		sta rom_sectorsread+1

rf1:		inc rom_sectorsread
		bne rf2
		inc rom_sectorsread+1
rf2:		
		; Write sector to ROM space
		; Map ($20000+rom_sectorsread*512) at $4000-$5FFF
		; Because MAP is relative, the map offset will be
		; $20000+rom_sectorsread*512-$4000
		; = $1C000+rom_sectorsread*512
		lda rom_sectorsread
		asl
		sta zptempv		
		lda rom_sectorsread
		lsr
		lsr
		lsr
		lsr
		lsr
		lsr
		lsr
		sta zptempv+1
		lda zptempv
		clc
		adc #$c0
		sta zptempv
		lda zptempv+1
		adc #$01
		ora #$40
		tax
		lda zptempv
		ldy #$00
		ldz #$00
		map
		eom

		; copy sector into slow ram
		ldx #$00
rr1:		lda $de00,x
		sta $4000,x
		lda $df00,x
		sta $4100,x
		inx
		bne rr1

		; clear memory mapping
		tya
		tax
		map
		eom		
		
		; see if there is another sector
		; (but don't try if we have read ~256KB already, since we are
		;  supposed to read 128KB only).
		lda rom_sectorsread+1
		cmp #$02
		beq romfilesizeerror
		jsr fs_readnextsector
		bcs rf1

		lda rom_sectorsread
		bne romfilesizeerror
		lda rom_sectorsread+1
		cmp #$01
		bne romfilesizeerror

		jmp infinity

romfilesizeerror:
		ldx #<msg_romfilesizeerror
		ldy #>msg_romfilesizeerror
		jsr printmessage

		; temporary infinite loop to catch us
infinity:	inc $07e7          ; $0400+(24*40)+39
		jmp infinity

sdcarderror:	ldx #<msg_sdcarderror
		ldy #>msg_sdcarderror
		jsr printmessage
		jmp infinity

badfs:		ldx #<msg_badformat
		ldy #>msg_badformat
		jsr printmessage
		jmp infinity
;;; ----------------------------------------------------------------------------
;;; FAT file system routines
;;; ----------------------------------------------------------------------------
toupper:	; convert ASCII character to upper case
		cmp #$60
		bcc tu1
		cmp #$7a
		bcs tu1
		and #$5f
tu1:		rts

fs_cd_rootdir:
		ldx #$00
cd1:		lda fs_rootdircluster,x
		sta fs_currentdircluster,x
		inx
		cpx #$04
		bne cd1
		sec
		rts

fs_opendir:
		; assume cluster for directory is already set
		ldx #$00
od1:		lda fs_currentdircluster,x
		sta fs_clusternumber,x
		inx
		cpx #$04
		bne od1
		lda #$00
		sta fs_direntrynumber
		jmp fs_openfile

fs_readdir:
		; read next entry from directory
		lda fs_direntrynumber
		cmp #$10

		bcc rd2

		; reached end of sector, so load next sector
		lda #$00
		sta fs_direntrynumber
		jsr fs_readnextsector
		; return with carry clear if we have readed the end of the directory
		bcs rd2
		rts

rd2:		; have sector, so can copy entry
		ldy #$00
		lda fs_direntrynumber
		and #$08
		bne rd3
		lda fs_direntrynumber
		asl
		asl
		asl
		asl
		asl
		tax
rd1:		lda $DE00,x
		sta fs_direntry,y
		inx
		iny
		cpy #$20
		bne rd1
rddone:		inc fs_direntrynumber
		sec		
		rts
rd3:		lda fs_direntrynumber
		asl
		asl
		asl
		asl
		asl
		tax
rd4:		lda $DF00,x
		sta fs_direntry,y
		inx
		iny
		cpy #$20
		bne rd4
		inc fs_direntrynumber
		sec
		rts		

fs_setfile:
		; get cluster from directory entry and store in cluster number
		lda fs_direntry+20
		sta fs_clusternumber+2
		lda fs_direntry+21
		sta fs_clusternumber+3
		lda fs_direntry+26
		sta fs_clusternumber+0
		lda fs_direntry+27
		sta fs_clusternumber+1
		sec
		rts		

fs_openfile:
		; zero sector number in cluster
		lda #$00
		sta fs_sector_in_cluster

		; Read first sector of first cluster
		; (no need to add fs_sector_in_cluster since it is zero here)
		jsr fs_clustertosector
		bcs of1
		rts
of1:		
		jsr sd_fix_sectornumber
		jmp sd_readsector

fs_readnextsector:
		; load next sector of file
		jsr sd_inc_fixedsectornumber
		inc fs_sector_in_cluster
		lda fs_sector_in_cluster
		cmp fs_sectorspercluster
		bne rs6
		; need to advance cluster number
		lda #$00
		sta fs_sector_in_cluster
		jsr fs_getnextclusteroffile
		bcs rs5
		; end of file or other error
		rts
rs5:		; cluster number is right
		jsr fs_clustertosector
		jsr sd_fix_sectornumber
rs6:		jmp sd_readsector

fs_getnextclusteroffile:
		; read chained cluster number for fs_clusternumber

		; FAT32 uses 32-bit cluster numbers.
		; 512 / 4 = 128 cluster numbers per sector.
		; To get the sector of the FAT containin a particular
		; cluster entry, we thus need to shift the cluster number
		; right 7 bits.  Then we add the start sector number of the FAT.

		; get cluster number into sector number registers
		ldx #$00
g1:		lda fs_clusternumber,x
		sta $D681,x
		inx
		cpx #$04
		bne g1

		; shift right 7 times
		ldy #$07
g31:		clc		
		ror $d684
		ror $d683
		ror $d682
		ror $d681
		dey
		bne g31

		; add start of partition offset
		ldx #$00
		clc
		php
g33:		plp
		lda $d681,x
		adc part_startsector,x
		sta $d681,x
		php
		inx
		cpx #$04
		bne g33
		plp

		; add start of fat offset
		ldx #$00
		clc
		php
g3:		plp
		lda $d681,x
		adc fs_startfat,x
		sta $d681,x
		php
		inx
		cpx #$04
		bne g3
		plp

		; turn sector number into byte address for non-SDHC cards
		jsr sd_fix_sectornumber

		; read FAT sector
		jsr sd_readsector
		bcc gfail

		; now read the right four bytes out.
		; cluster number needs to be shifted left 2 bits.
		; we only need the lowest order byte.
		lda fs_clusternumber
		asl
		asl
		tax
		ldy #$00
		lda fs_clusternumber
		and #$40
		bne ghigh
g6:		lda $de00,x
		sta fs_clusternumber,y
		inx
		iny
		cpy #$04
		bne g6
		bra gcheck
ghigh:		lda $df00,x
		sta fs_clusternumber,y
		inx
		iny
		cpy #$04
		bne ghigh
gcheck:		; check that resulting cluster number is valid.

		; First, only the lower 28-bits are valid
		lda fs_clusternumber+3
		and #$0f
		sta fs_clusternumber+3

		; Now check for special values:
		; cluster 0 is invalid
		lda fs_clusternumber+3
		ora fs_clusternumber+2
		ora fs_clusternumber+1
		ora fs_clusternumber
		cmp #$00
		beq gfail
		; $FFFFFF7 = bad cluster
		; $FFFFFFF = end of file
		lda fs_clusternumber+3
		cmp #$0f
		bne gok
		lda fs_clusternumber+2
		cmp #$ff
		bne gok
		lda fs_clusternumber+1
		cmp #$ff
		bne gok
		lda fs_clusternumber
		cmp #$ff
		beq gfail
		cmp #$f7
		beq gfail

gok:		; cluster number is okay
		sec
		rts

gfail:		
		clc
		rts
		

fs_clustertosector:
	; convert a cluster number in fs_clustertosector into a sector 
	; number loaded into $D681-$D684.

	  	; put cluster number into sector number	
		ldx #$03
l21:		lda fs_clusternumber,x
		sta $D681,x
		dex
		bpl l21

		; subtract number of reserved clusters
		ldx #$03
		sec
l17:		lda $D681,x
		sbc fs_reservedclusters,x
		sta $D681,x
		dex
		bpl l17

		; now shift it left according to fs_sectorspercluster
		lda fs_sectorspercluster
		tay
		and #$fe
		beq multipliedclusternumber
l22:		ldx #$00
		clc
l18:		lda $D681,x
		rol
		sta $D681,x
		inx
		cpx #$04
		bne l18
		tya
		lsr
		tay
		and #$fe
		bne l22
multipliedclusternumber:

		; skip over filesystem reserved and FAT sectors
		ldx #$00
		clc
		php
l23:		plp
		lda $D681,x
		adc fs_syssectors,x
		sta $D681,x
		php
		inx
		cpx #$04
		bne l23
		plp	

		; add start sector of partition
		ldx #$00
		clc
		php
l24:		plp
		lda $D681,x
		adc part_startsector,x
		sta $D681,x
		php
		inx
		cpx #$04
		bne l24
		plp
		
		; return success
		sec
		rts

printsectornumber:
		ldx #<msg_sectornumber
		ldy #>msg_sectornumber
		jsr printmessage
		ldy #$00
		ldx #$03
l19:		lda fs_clusternumber,x
		taz
		phx
		jsr printhex
		plx
		dex
		bpl l19
		ldx #$03
l20:		lda $D681,x
		taz
		phx
		jsr printhex
		plx
		dex
		bpl l20
		rts

;;; ----------------------------------------------------------------------------
;;; MBP / partition routines
;;; ----------------------------------------------------------------------------

; read master boot record. Does not sanity check anything.
readmbr:
		; begin by resetting SD card
		jsr sdreset
		bcs l7
		rts

l7:		ldx #<msg_foundsdcard
		ldy #>msg_foundsdcard
		jsr printmessage
	
		; MBR is sector 0	
		lda #$00
		sta $D681
		sta $d682
		sta $d683
		sta $d684

		jmp sd_readsector

;;; ----------------------------------------------------------------------------
;;; SD Card access routines
;;; ----------------------------------------------------------------------------
sdreset:
		; try SD-HC mode first
		lda #$41
		sta $D680
		jsr sd_resetsequence
		bcc sdr1
		rts
sdr1:		; fall back to SD mode
		lda #$42
		sta $d680
		; fall through		

sd_resetsequence:
		; write $00 to $D680 to start reset
		lda #$00
		sta $D680
		jsr sdtimeoutreset
re1:		jsr sdreadytest
		bcs re1done	; success, so return
		bne re1		; not timed out, so keep trying
		rts 		; timeout, so return
re1done:	
		; write $01 to $D680 to complete reset
		lda #$01
		sta $D680
		jsr sdtimeoutreset
re2:		jsr sdreadytest
		bcs re2done	; success, so return
		bne re2		; not timed out, so keep trying
		rts 		; timeout, so return
re2done:
		; give card some time to settle after reset, otherwise 
		; reading sectors will fail
		jsr sdwaitawhile

		jsr sdmapsectorbuffer

		; write $02 to $D680 to read MBR as a test of reset
		lda #$02
		sta $D680
		jsr sdtimeoutreset
		
re3:		; allow time for read to happen
		lda $d680
		jsr sdreadytest
		bcs redone	; success, so return
		bne re3		; not timed out, so keep trying
		; timeout -- so call reset again
		rts
redone:		
		sec
		rts

sdwaitawhile:	jsr sdtimeoutreset
sw1:		inc $0300
		bne sw1
		inc $0301
		bne sw1
		inc $0302
		bne sw1
		rts

		; count to timeout value when trying to read from SD card
sdtimeoutreset:
		lda #$00
		sta $0300
		sta $0301
		lda #$f0
		sta $0302
		rts

sdreadytest:	; check if SD card is ready, or if timeout has occurred
		; C is set if ready.
		; Z is set if timeout has occurred.
		lda $d680
		and #$03
		beq sdisready
		inc $0300
		bne sr1
		inc $0301
		bne sr1
		inc $0302
		bne sr1

		; timeout
		lda #$00 ; set Z

sr1:		clc
		rts
sdisready:	sec
		rts

sdmapsectorbuffer:
		lda #$81
		sta $D680
		sec
		rts

sdunmapsectorbuffer:
		lda #$82
		sta $D680
		sec
		rts

sd_readsector:
		; Assumes fixed sector number (or byte address in case of SD cards)
		; is loaded into $D681 - $D684		

		; check if sd card is busy
		lda $d680
		and #$01
		bne rsbusyfail

		; try reading sector fast the first time
		jmp rs4

redoread:	
		; when retrying, introduce a delay.  This seems to be needed often
		; when reading the first sector after SD card reset.  
		ldx #$f0
		ldy #$00
		ldz #$00
r1:		inz
		bne r1
		iny
		bne r1
		inx
		bne r1

rs4:
		; ask for sector to be read
		lda #$02
		sta $d680

		; wait for sector to be read
		jsr sdtimeoutreset
rs3:		
		jsr sdreadytest
		bcs rsread
		bne rs3
		jmp rereadsector

rsread:
		lda $d680
		and #$01
		bne rs3

		; check that we read 512 bytes
		lda $d688
		lda $d689

		cmp #$02
		bne redoread

		sec
		rts

		; reset sd card and try again
rereadsector:
		jsr sdreset		
		jmp rs4

rsbusyfail:     ; fail
		clc 
		rts


printsdaddress:
		ldx #<msg_sdaddress
		ldy #>msg_sdaddress
		jsr printmessage
		ldy #$00
		ldz $D684
		jsr printhex
		ldz $D683
		jsr printhex
		ldz $D682
		jsr printhex
		ldz $D681
		jmp printhex

sd_inc_fixedsectornumber:
		; increment fixed sector number.
		; if SDHC, then increment is simple.
		; if SD, then we add $200
		lda $D680
		and #$10
		bne sdhc1
		; sd card mode: add $200
		lda $d682
		clc
		adc #$02
		sta $d682
		bra s2
sdhc1:		; SDHC card mode: add 1
		inc $d681
		bcc s1
		inc $d682
		bcc s1
s2:		inc $d683
		bcc s1
		inc $d684
s1:		rts

sd_fix_sectornumber:
		; assumes sector number has been loaded into 
		; $D681 - $D684
		; We need to check if the card is SDHC or SD.
		; If SD, we need to shift sector number left 9 bits,
		; as SD cards address by byte, not sector.
		; If card is SD, then shift it all left nine bits
		; We detect SD versus SDHC by reading whether SD controller is
		; in SDHC or SD mode.
		lda $D680
		and #$10
		beq sdcardmode
		; SDHC mode, so nothing to do
		rts
sdcardmode:     
		; shift left 8 bits first
		lda $D683
		sta $D684
		lda $D682
		sta $D683
		lda $D681
		sta $D682
		lda #$00
		sta $D681
		; now shift it all left one bit
		lda $D682
		asl
		sta $D682
		lda $D683
		rol
		sta $D683
		lda $D684
		rol
		sta $D684
		rts

;;; ----------------------------------------------------------------------------
;;; ROM loading and manipulation routines
;;; ----------------------------------------------------------------------------

checkromok:
		; calculate checksum of loaded ROM ...
		jsr calcromsum
		; ... then fall through to testing it
testromsum:
		; have checksum for all slabs.
		; Map in ROM load record, and compare checksum
		; Here we have to use our extension to MAP to access >1MB
		; as only 128KB of slow ram is shadowed to $20000.
		; again, we have to take the relative nature of MAP, so
		; we ask for $FC000 to be mapped at $0000, which means that
		; $4000 will correspond to $0000 (MAP instruction address
		; space wraps around at the 1MB mark)
		
		; select 128MB mark for mapping lower 32KB of address space
		lda #$80
		ldx #$0f
		ldy #$00
		ldz #$00
		map
		; then map $FC000 + $4000 = $00000 at $4000-$7FFF
		lda #$c0
		ldx #$cf
		map
		eom
		
		lda $4000
		cmp checksum
		bne checksumfails
		lda $4001
		cmp checksum+1
		bne checksumfails
		lda $4002
		cmp checksum+2
		bne checksumfails

		jsr resetmemmap

		sec
		rts

		; check failed
checksumfails:	clc
		rts

calcromsum:	; calculate checksum of 128KB ROM
		
		; use MAP to map C65 ROM address space in 16KB
		; slabs at $4000-$7FFF.  Check sum each, and
		; then compare checksum to ROM load record.
		; ROMs get loaded into slow RAM at $8020000-$803FFFF,
		; which is shadowed for reading using C65 MAP instruction to
		; C65 address space $20000-$3FFFF.
		; Checksum and ROM load record are stored in
		; $8000000 - $800FFFF, i.e., the first 64KB of
		; slow RAM.
		;
		; The 4510 MAP instruction does not normally provide access to the
		; full 28-bit address space, so we need to use a trick.
		; We do this by interpretting a MAP instruction that says to
		; map none of the 8KB pages, but provides an offset in the range
		; $F0000 - $FFF00 to set the "super page" register for that 32KB
		; moby to bits 8 to 15 of the offset.  In practice, this means
		; to allow mapping of memory above 1MB, the MB of memory being
		; selected is chosen by the contents of A and Y registers when 
		; X and Z = $0F.
		; 
				
		; reset checksum
		; checksum is not all zeroes, so that if RAM initialises with
		; all zeroes, including in the checksum field, the checksum will
		; not pass.
		lda #$03
		sta checksum
		sta checksum+1
		sta checksum+2
		sta checksum+3

		; start with bottom 16KB of ROM
		; we count in 16KB slabs, and ROM starts at 128KB mark,
		; so we want to check from the 8th to 15th slabs inclusive.
		lda #$08
		sta romslab

		; Summing can be done using normal use of MAP instruction,
		; since slow RAM is shadowed as ROM to $20000-$3FFFF

sumslab:	; romcheckslab indicates which 16KB piece.
		; MAP uses 256-byte granularity, so we need to shift left
		; 6 bits into A, and right 2 bits into X.
		; We then set the upper two bits in X to indicate that the mapping
		; applies to blocks 2 and 3.
		; BUT MAP is relative, and since we are mapping at the 16KB mark,
		; we need to subtract 1 lot of 16KB from the result.
		; this is easy -- we just sbc #$01 from romslab before using it.
		lda romslab
		sec 
		sbc #$01
		lsr
		lsr
		ora #$c0
		tax
		lda romslab
		sec
		sbc #$01
		asl
		asl
		asl
		asl
		asl
		asl
		; don't mess with mapping of upper 32KB.
		ldy #$00
		ldz #$00
		map
		eom
		
		; sum contents of 16KB slab
		lda #$00
		sta zptempv
		lda #$40
		sta zptempv+1
		
sumpage:	ldy #$00
sumbyte:	lda checksum
		clc
		adc (zptempv),y
		sta checksum
		bcc l6
		inc checksum+1
		bcc l6
		inc checksum+2
l6:		iny
		bne sumbyte
		inc zptempv+1
		lda zptempv+1
		cmp #$80
		bne sumpage
		
		inc romslab
		lda romslab
		cmp #$10
		bne sumslab

		jmp resetmemmap

;;; ----------------------------------------------------------------------------
;;; Display and basic IO routines
;;; ----------------------------------------------------------------------------

resetdisplay:
		; reset screen
		lda #$00
		sta $D020
		sta $D021
		; We use VIC-II style registers as this resets video frame in
		; least instructions, and 40 columns is fine for us.
		lda #$1B
		sta $D011
		lda #$C8
		sta $D016
		lda #$14
		sta $D018
		; point VIC-IV to bottom 16KB of display memory
		lda #$ff
		sta $DD01
		sta $DD00
		rts

resetpalette:
		; reset VIC-IV palette to sensible defaults.
		; for now, just define black and white
		lda #$00
		sta $D100
		sta $D200
		sta $D300
		lda #$ff
		sta $D101
		sta $D201
		sta $D301
		rts

; erase standard 40-column screen
erasescreen:
		ldx #$00
		lda #$20
		ldy #$01
l3:		; fill screen with spaces
		sta $0400,x
		sta $0500,x
		sta $0600,x
		sta $0700,x
		; colour RAM to white
		sty $d800,x
		sty $d900,x
		sty $da00,x
		sty $db00,x
		inx
		bne l3

		lda #$00
		sta screenrow

		rts

checkpoint:
		pha
		ldx #<msg_checkpoint
		ldy #>msg_checkpoint
		jsr printmessage
		ldy #$00
		plz
		jmp printhex

printmessage:
		stx zptempv
		sty zptempv+1
		lda #$00
		sta zptempv2
		lda #$04
		sta zptempv2+1
		ldx screenrow
pm2:		cpx #$00
		beq pm1
		clc
		lda zptempv2
		adc #$28
		sta zptempv2
		lda zptempv2+1
		adc #$00
		; if reached bottom of screen, then loop back to top of screen
		cmp #$08
		bcc pm5		
		lda #$00
		sta zptempv2
		lda #$04
pm5:		sta zptempv2+1
		dex
		bne pm2
pm1:
		ldy #$27
pm3:		lda (zptempv),y
		; convert ASCII/PETSCII to screen codes
		cmp #$40
		bcc pm4
		and #$1f
pm4:		sta (zptempv2),y
		dey
		bpl pm3

		inc screenrow

		rts

printhex:	
		; output contents of Z on last written screen line
		tza
		lsr
		lsr
		lsr
		lsr
		jsr printhexdigit		
		tza
		and #$0f
printhexdigit:
		; find next $ sign to replace with hex digit
		tax
phd3:		lda (zptempv2),y
		cmp #$24
		beq phd2
		iny
		cpy #$28
		bne phd3
		rts
phd2:		txa

		ora #$30
		cmp #$3a
		bcc phd1
		sbc #$39
phd1:		sta (zptempv2),y
		iny
		rts

; Transfer control to C64 kernel.
; (This also allows entry to C65 mode, because the
;  C64-mode kernel on the C65 checks if C65 mode
;  should be entered.)
go64:
		; C64 IO map
		clc
		jsr enhanced_io
		; copy routine to stack to switch to
		; C64 memory map and enter via reset
		; vector.  
		ldx #$00
l2:		lda go64ramroutine,x
		sta $0140,x
		inx
		cpx #go64ramroutineend-go64ramroutine
		bne l2
		jmp $0140
		
; This routine is copied to RAM, since writing to $01
; will de-map the kickstart ROM.
go64ramroutine:	lda #$37
		sta $01
		sta $00
		jmp (reset_vector)
go64ramroutineend:

; reset memory map to default
resetmemmap:
		lda #$00
		ldx #$0f
		ldy #$00
		ldz #$0f
		map
		; also clear memory MAP MB offset register
		tax
		taz
		map
		eom
		rts


; If C=1, enable enhanced IO bank, else return to
; C64 standard IO map.
enhanced_io:
		bcs l1
		; Return to VIC-II / C64 IO
		lda #$00
		sta $D02F
l1:		; Enable VIC-IV / C65GS IO
		lda #$47
		sta $D02F
		lda #$53
		sta $D02F
		RTS

; messages.  All have to be 40 bytes long
msg_kickstart:        .byte "C65GS KICKSTART V00.00 PRE-ALPHA        "
msg_romok:            .byte "ROM CHECKSUM OK - BOOTING               "
msg_rombad:	      .byte "ROM CHECKSUM FAIL - LOADING ROM         "
msg_tryingsdcard:     .byte "LOOKING FOR SDCARD...                   "
msg_foundsdcard:      .byte "FOUND AND RESET SDCARD                  "
msg_sdcarderror:      .byte "ERROR READING FROM SD CARD              "
msg_badformat:	      .byte "BAD MBR OR DOS BOOT SECTOR.             "
msg_sdcardfound:      .byte "READ PARTITION TABLE FROM SDCARD        "
msg_partitiondetails: .byte "PARTITION 1($$) @$$$$$$$$, SIZE $$$$$$$$"
msg_fsdetails: 	      .byte " FS SPC:$$ RSVSEC:$$$$ RSVCLUS:$$$$$$$$ "
msg_reservedsectors:  .byte " SYS:$$$$$$$$ DAT:$$$$$$$$ CLUS:$$$$$$$$"
msg_sectornumber:     .byte " CLUSTER:$$$$$$$$ -> SECTOR:$$$$$$$$    "
msg_foundromfile:     .byte "FOUND ROM FILE. START CLUSTER = $$$$$$$$"
msg_romfilesizeerror: .byte "ROM FILE WRONG SIZE: MUST BE 128KB      "
msg_sdaddress:	      .byte " D684-D681=$$$$$$$$                     "
msg_checkpoint:	      .byte " CHECKPOINT $$ $$ $$ $$ $$ $$ $$ $$ $$  "

; filename of ROM we want to load in FAT directory format
txt_c65gsrom:	      .byte "C65GS   ROM"

		.checkpc $2F00
		.advance $2F00

;;; ----------------------------------------------------------------------------
;;; CPU entry vectors
;;; ----------------------------------------------------------------------------
		.org $FF00		
reset_entry:		
		; get CPU state sensible
		sei
		cld
		cle
		ldx #$ff
		txs
		
		; Copy $E000-$FFFF to $1000-$2FFF so that sdcard routines are run
		; from chipram.
		lda #$00
		sta $c0
		lda #$10
		sta $c1
		lda #$00
		sta $c2
		lda #$e0
		sta $c3
		ldy #$00
c1:		lda ($C2),y
		sta ($C0),y
		iny
		bne c1
		inc $c1
		inc $c3
		bne c1


		jmp kickstart_entry

; For now we have no use for NMI or IRQ
nmi_entry:	rti
irq_entry:	rti

; 6502 interrupt and reset vectors
       		.checkpc $FFFA
		.advance $FFFA
nmi_vector:	.word nmi_entry
reset_vector:	.word reset_entry
irq_vector:	.word irq_entry

		 .outfile "kickstart65gs.bin"