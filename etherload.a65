; Simple ethernet programme loader for C65GS.
; Reads and checks packets, and then runs code contained in the packets.
; This keeps the programme VERY small <128 bytes

	 .word $CF80
	 .org $CF80
	 .scope

programentrypoint:
	
	; C65GS io
	lda #$47
	sta $d02f
	lda #$53
	sta $D02f

	; Map ethernet registers at $6000 - $7FFF
	
	; Ethernet controller really lives $FFDE000 - $FFDEFFF, so select $FF megabyte section for MAP LO
	lda #$ff
	ldx #$0f
	ldy #$00
	ldz #$00
	map
	eom

	; now enable mapping of $DE000-$DFFFF at $6000
	; MAPs are offset based, so we need to subtract $6000 from the target address
	; $DE000 - $6000 = $D8000
	lda #$80
	ldx #$8d
	ldy #$00
	ldz #$00
	map
	eom

	; Ethernet registers should now be visible from $6000 - $6FFF
	; read buffer will be at $6800 - $6FFF
	; length of frame is in $6FFE / $6FFF in little-endian byte order
	; so LDA $6FFE ; LDX $6FFF ; jsr $BDCD should print packet length to screen

	; make sure ethernet transceiver is on and not generating IRQs
	; (we will poll it)
	lda #$01
	sta $d6e1

loop:

waitingforpacket:
	lda $d6e1
	and #$20
	beq waitingforpacket
	; clear eth RX signal, and leave ethernet tranceiver on
	; and make last used RX buffer visible
	lda $d6e1
	and #$04
	lsr
	ora #$01
	sta $d6e1


	; Got a packet.
	; check whether it is UDP port 4510

	; is it IPv4?
	lda $6810
	cmp #$45
	bne waitingforpacket
	; is it UDP?
	lda $6819
	cmp #$11
	bne waitingforpacket
	; UDP port #4510
	lda $6826
	cmp #>4510
	bne waitingforpacket
	lda $6827
	cmp #<4510
	bne waitingforpacket

	; write ethernet status to $0427
	lda $d6e1
	sta $0427

	; Let's copy 512 bytes of packet to the screen repeatedly
	ldx #$00
loop1:	lda $6800,x
	sta $0428,x
	lda $6900,x
	sta $0528,x
	inx
	bne loop1

	; packet body begins at $0444 / $682C.
	; if it begins with $A9 = LDA immediate, then jsr to the packet body.
	; packet body can do whatever is required to load data, keeping this
	; programme very simple.
	lda $682c
	cmp #$a9
	bne loop
	jsr $682C

	jmp loop

	.checkpc $CFFF
	.scend

	.outfile "etherload.prg"