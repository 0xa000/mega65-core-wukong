;
;  Test programme for advanced text mode.
;  This test concentrates on 16-bit text mode and displays proportional font text.
;

; Include C64 BASIC program load header

	 .word $0801
	 .org $0801

	 .scope
	 .word _next, 10                       ; Next line and current line number
	 .byte $97, "2,0:", $9e, " 2014", $AA, "65",0      ; POKE 2,0 : SYS 2014+65
_next:	 .word 0

iter1:	 .byte 0

	 .checkpc 2079
	 .advance 2079

programentrypoint:
	; Enable C65GS IO
	lda #$47
	sta $d02f
	lda #$53
	sta $d02f

	; Select 960x600 resolution
	lda #$40
	sta $d042
	lda #$01
	sta $d043

	; Enable 16-bit text mode, with full-colour characters
	lda #$47
	sta $d054

	; Make virtual row length $FF bytes
	lda #$ff
	sta $d040
	lda #$00
	sta $d041

	; Put screen RAM at $3000
	lda #$00
	sta $D060
	lda #$30
	sta $D061
	lda #$00
	sta $D062
	sta $D063
	; colour RAM starting at $0000
	sta $D064
	sta $D065

	; Set palette to grey gradient
	ldx #$10
pl:	txa
	lsr
	lsr
	lsr
	lsr
	and #$0f
	sta $d100,x
	sta $d200,x
	sta $d300,x
	inx
	bne pl
	
	lda #<unicodestring
	ldx #>unicodestring
	jsr printunicodemessage	

	; XXX set colour RAM

	; then do nothing
loop:
	jmp loop
	
; Text to display expressed as list of 16-bit unicode points.
unicodestring:
       .word 'H,'e,'l,'l,'o,$20,'W,'o,'r,'l,'d
       .word $000d
       .word $05d4,$05d3,$05d2,$05d1,$05d0
       .word $000d
       .word 0


printunicodemessage:
	; Display a unicode string using the proportional font loaded at
	; fontheader.
	
	; save pointer to message
	sta $fd
	stx $fe

pum_nextpoint:
	; read next glyph number
	ldy #$00
	lda ($fd),y
	sta glyph_unicode_point
	iny
	lda ($fd),y
	sta glyph_unicode_point+1
	; advance message pointer
	inw $fd
	inw $fd

	; return if we have hit null character ($0000)
	; as this marks end of string
	ora glyph_unicode_point
	bne pum1
	rts
pum1:
	; non-zero point
	jsr glyph_print
	jmp pum_nextpoint

glyph_lookup:
	; Get important information for a glyph from a font.
	
	; Start by building pointer to glyph list in font.
	; glyph list is always at header+$100
	lda fontheader+$100
	sta $57
	lda fontheader+$101
	sta $58
	; also get the number of glyphs so that we know when to stop looking
	lda fontheader+$87
	sta font_glyphs
	lda fontheader+$88
	sta font_glyphs+1
	
	; start looking at entry 0
	lda #$00
	sta temp_word
	sta temp_word+1

gl_tryglyph:
	ldz #$00
	lda ($57),z
	cmp glyph_unicode_point
	bne gl_notthisglyph
	inz
	lda ($57),z
	cmp glyph_unicode_point+1
	beq gl_foundglyph
gl_notthisglyph:
	; advance address by 5 bytes to next glyph entry 
	lda temp_word
	clc
	adc #$05
	sta temp_word
	lda temp_word+1
	adc #$00
	sta temp_word

	; decrement number of glyphs left to check
	lda font_glyphs
	sec
	sbc #$01
	sta font_glyphs
	lda font_glyphs+1
	sbc #$00
	sta font_glyphs+1

	; see if there are more glyphs to consider
	lda font_glyphs
	ora font_glyphs+1
	bne gl_tryglyph
gl_nomoreglyphs:
	ldz #$00
	; FAIL no such point in font
	lda #$00
	sta glyph_address
	sta glyph_address+1
	sta glyph_tiles_high
	sta glyph_tiles_wide
	sta glyph_horizontal_trim
	sta glyph_width
	sta glyph_width+1
	sta glyph_tile_list_address
	rts
gl_foundglyph:
	; We now know the point number.
	



	; finally work out glyph width in pixels
	lda glyph_tiles_wide
	asl
	asl
	asl
	sta glyph_width
	lda glyph_tiles_wide
	lsr
	lsr
	lsr
	lsr
	lsr
	sta glyph_width+1
	lda glyph_width
	sec
	sbc glyph_horizontal_trim
	sta glyph_width
	lda glyph_width+1
	sbc #$00
	sta glyph_width+1

	rts

glyph_print:
	lda glyph_unicode_point
	cmp #$0d
	bne gp1
	lda glyph_unicode_point+1
	cmp #$00
	bne gp1
	
	; Found carriage return
	jmp unicode_newline
gp1:
	; XXX Add other non-printable glyphs (eg colour changes) here

	; Printable glyph

	; Get details about glyph
	jsr glyph_lookup

	; work out how wide the line would be with this glyph added
	lda glyph_width
	clc
	adc screen_line_pixels
	sta temp_word
	lda glyph_width+1
	adc screen_line_pixels+1
	cmp screen_line_pixels_width+1
	bcc glyph_fits
	beq glyph_might_fit
glyph_doesnt_fit:
	; start a new line if the glyph won't fit on the current line
	jsr unicode_newline
	bra glyph_fits
glyph_might_fit:
	lda temp_word
	cmp screen_line_pixels_width
	bcs glyph_doesnt_fit
glyph_fits:

	; Draw glyph tile numbers into screen ram buffer

	rts

unicode_newline:
	; Clear unicode line status

	; Render the current line
	; (this will add the $FFFF EOL marker)
	jsr unicode_apply_line

	; Advance the screen RAM pointer to take account of the line
	lda screen_ram_applied_pointer
	sta screen_ram_pointer
	lda screen_ram_applied_pointer+1
	sta screen_ram_pointer+1

unl1:
	; reset horizontal position
	lda #$00
	sta screen_line_pixels
	sta screen_line_pixels+1
	sta screen_line_bytes

	rts

unicode_apply_line:
	; Take the contents of the screen RAM buffer and colour RAM buffer and
	; apply (draw) it onto the screen

	; get pointer to colour RAM buffer
	lda #<colour_ram_buffer
	sta $57
	lda #>colour_ram_buffer
	sta $58

	ldy #$00
ual_row:
	; For this screen row, get the address of the screen ram buffer
	lda #<screen_ram_buffer
	sta $59
	tya
	clc
	adc #>screen_ram_buffer
	sta $5a

	; and also of the screen RAM where we need to write
	lda screen_ram_base
	clc
	adc screen_ram_pointer
	sta $5b
	lda screen_ram_base+1
	adc screen_ram_pointer+1
	sta $5c
	
	; and also the colour RAM where we need to write
	; XXX - this only works for first KB of colour RAM - should use DMA
	; to write colour RAM (and in fact to apply all the data)
	lda #<$D800
	clc
	adc screen_ram_pointer
	sta $5d
	lda #>$D800
	adc screen_ram_pointer+1
	sta $5e

	; copy bytes
	ldz #$00
ual_1:	lda ($57),z
	sta ($59),z
	lda ($5b),z
	sta ($5d),z    ; XXX only works for first 1KB of colour RAM - should use DMA
	inz
	cpz screen_line_bytes
	bne ual_1
	; now append $FFFF to screen RAM and dummy bytes to colour RAM
	lda #$FF
	sta ($59),z
	sta ($5D),z
	inz
	sta ($59),z
	sta ($5D),z
	inz

	; advance screen RAM pointer
	tza
	clc
	adc screen_ram_pointer
	sta screen_ram_pointer
	lda screen_ram_pointer+1
	adc #$00
	sta screen_ram_pointer+1
	
	; clear Z so we don't upset and 6502 code
	ldz #$00

	; check for next row
	iny
	cpy screen_line_height
	bne ual_row

	rts

; scratch space
temp_word: .word 0

; number of unicode points in font
font_glyphs:
	.word 0

; current glyph being drawn
glyph_unicode_point:
	.word 0
glyph_address:
	.word $0000
glyph_tiles_high:
	.byte 0
glyph_tiles_underhang:
	.byte 0
glyph_tiles_wide:
	.byte 0
glyph_horizontal_trim:
	.byte 0
; width of glyph in pixels
glyph_width:
	.word 0
; address of glyph tile list
glyph_tile_list_address:
	.word 0

; Base number of glyph tiles
; Tiles are at $4000, so base number is $4000/64 = $100
; this number gets added to the tile numbers extracted from the font
; to compute the VIC-IV tile number that points to the data.
glyph_tile_base:
	.word $0100

; Where screen RAM starts
screen_ram_base:
	.word $3000
; Where we are relative to screen RAM for start of line
screen_ram_pointer:
	.word $0000
; Where we are relative to screen RAM after rendering the current line
screen_ram_applied_pointer:
	.word $0000
; width of screen lines in pixels
screen_line_pixels_width:
	.word 960
; number of pixels used on current line
screen_line_pixels:
	.word $0000
; number of bytes used to encode current screen line.
; when end of line is reached, this is used to eliminate the excess characters.
screen_line_bytes:
	.byte 0
; height of current line in 8x8 tiles (including underhang)
screen_line_height:
	.byte 3
; number of those 8x8 tiles that are for underhang
screen_line_underhang_height:
	.byte 1
; buffer for screen lines.  256 bytes per line in the line buffer for screen RAM
; and colour RAM each limits lines to 128 8x8 tiles per line.  This seems a
; reasonable memory/max line length trade-off.  The trickier trade-off is the
; maximum number of tiles high that a row can be.  This will need to be reworked
; later, but for now, we will allow a line to be 8 tiles high. 8x256 = 2K.
; colour RAM only needs one row of buffer, since the colour information will be
; duplicated on each row of tiles.
screen_ram_buffer:
	.advance screen_ram_buffer+$800
colour_ram_buffer:
	.advance colour_ram_buffer+$100
	

; Keep $3000 - $3FFF for screen RAM
	.checkpc $3000
	.advance $3000

; 

; Include proportional font at $4000 (the file has 2 byte address header, so
; start at $3FFE
	.checkpc $3ffe
	.advance $3ffe
	.alias fontheader $4000

	.incbin "dejavus.f65"

	.scend

	.outfile "textmodetest.prg"