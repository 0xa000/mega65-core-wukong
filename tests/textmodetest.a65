;
;  Test programme for advanced text mode.
;  This test concentrates on 16-bit text mode and displays proportional font text.
;

; Include C64 BASIC program load header

	 .word $0801
	 .org $0801

	 .scope
	 .word _next, 10                       ; Next line and current line number
	 .byte $97, "2,0:", $9e, " 2014", $AA, "65",0      ; POKE 2,0 : SYS 2014+65
_next:	 .word 0

iter1:	 .byte 0

	 .checkpc 2079
	 .advance 2079

programentrypoint:
	; Enable C65GS IO
	lda #$47
	sta $d02f
	lda #$53
	sta $d02f

	; Select 960x600 resolution
	lda #$40
	sta $d042
	lda #$01
	sta $d043

	; Enable 16-bit text mode, with full-colour characters
	lda #$47
	sta $d054

	; Make virtual row length $FF bytes
	lda #$ff
	sta $d040
	lda #$00
	sta $d041

	; Put screen RAM at $3000
	lda #$00
	sta $D060
	lda #$30
	sta $D061
	lda #$00
	sta $D062
	sta $D063
	; colour RAM starting at $0000
	sta $D064
	sta $D065

	; Set palette to grey gradient
	ldx #$10
pl:	txa
	lsr
	lsr
	lsr
	lsr
	and #$0f
	sta $d100,x
	sta $d200,x
	sta $d300,x
	inx
	bne pl
	
	; calculate base tile number for this face
	jsr face_calculate_tile_base

	; Print a short Unicode encoded message using the proportional font we
	; have loaded
	lda #<unicodestring
	ldx #>unicodestring
	jsr printunicodemessage	

	; then do nothing
loop:
	jmp loop
	
; Text to display expressed as list of 16-bit unicode points.
unicodestring:
       .word 'H,'e,'l,'l,'o,$20,'W,'o,'r,'l,'d
       .word $000d
       .word $05d4,$05d3,$05d2,$05d1,$05d0
       .word $000d
       .word 0


printunicodemessage:
	; Display a unicode string using the proportional font loaded at
	; fontheader.
	
	; save pointer to message
	sta $fd
	stx $fe

pum_nextpoint:
	; read next glyph number
	ldy #$00
	lda ($fd),y
	sta glyph_unicode_point
	iny
	lda ($fd),y
	sta glyph_unicode_point+1
	; advance message pointer
	inw $fd
	inw $fd

	; return if we have hit null character ($0000)
	; as this marks end of string
	ora glyph_unicode_point
	bne pum1
	rts
pum1:
	; non-zero point
	jsr glyph_print
	jmp pum_nextpoint

face_calculate_tile_base:
	; work out the base tile number for this font
	lda fontheader+$84
	clc
	adc #<fontheader
	sta glyph_tile_base
	lda fontheader+$85
	adc #>fontheader
	sta glyph_tile_base+1
	lda fontheader+$86
	adc #$00
	sta glyph_tile_base+2
	; shift right six times to divide by $40
	ldx #$06
gl_2:	lsr glyph_tile_base+2
	ror glyph_tile_base+1
	ror glyph_tile_base
	dex
	bne gl_2
	rts	

glyph_lookup:
	; Get important information for a glyph from a font.
	
	; Start by building pointer to glyph list in font.
	; glyph list is always at header+$100
	lda fontheader+$100
	sta $57
	lda fontheader+$101
	sta $58
	; also get the number of glyphs so that we know when to stop looking
	lda fontheader+$87
	sta font_glyphs
	lda fontheader+$88
	sta font_glyphs+1
	
	; start looking at entry 0
	lda #$00
	sta temp_word
	sta temp_word+1

gl_tryglyph:
	ldz #$00
	lda ($57),z
	cmp glyph_unicode_point
	bne gl_notthisglyph
	inz
	lda ($57),z
	cmp glyph_unicode_point+1
	beq gl_foundglyph
gl_notthisglyph:
	; advance address by 5 bytes to next glyph entry 
	lda temp_word
	clc
	adc #$05
	sta temp_word
	lda temp_word+1
	adc #$00
	sta temp_word

	; decrement number of glyphs left to check
	lda font_glyphs
	sec
	sbc #$01
	sta font_glyphs
	lda font_glyphs+1
	sbc #$00
	sta font_glyphs+1

	; see if there are more glyphs to consider
	lda font_glyphs
	ora font_glyphs+1
	bne gl_tryglyph
gl_nomoreglyphs:
	ldz #$00
	; FAIL no such point in font
	lda #$00
	sta glyph_address
	sta glyph_address+1
	sta glyph_tiles_high
	sta glyph_tiles_wide
	sta glyph_horizontal_trim
	sta glyph_width
	sta glyph_width+1
	sta glyph_tile_list_address
	rts
gl_foundglyph:
	; We have found the glyph entry in the font.
	; Get the address of the tile map for this glyph
	ldz #$02
	lda ($57),z
	sta glyph_tile_list_address
	inz
	lda ($57),z
	sta glyph_tile_list_address+1
	ldz #$00

	; now get pointer to tile list
	lda glyph_tile_list_address
	clc
	adc #<fontheader
	sta $57
	lda glyph_tile_list_address+1
	adc #>fontheader
	sta $58

	; Get size information from tile list
	lda ($57),z
	sta glyph_tiles_high
	inz
	lda ($57),z
	sta glyph_tiles_underhang
	inz
	lda ($57),z
	sta glyph_tiles_wide
	inz
	lda ($57),z
	sta glyph_horizontal_trim
	ldz #$00

	; Now put final tile list address in place
	lda $57
	clc
	adc #$04
	sta glyph_tile_list_address
	lda $58
	adc #$00
	sta glyph_tile_list_address

	; Finally work out the width of the this glyph in pixels
       lda glyph_tiles_wide
       asl
       asl
       asl
       sta glyph_width
       lda glyph_tiles_wide
       lsr
       lsr
       lsr
       lsr
       lsr
       sta glyph_width+1
       lda glyph_width
       sec
       sbc glyph_horizontal_trim
       sta glyph_width
       lda glyph_width+1
       sbc #$00
       sta glyph_width+1

	rts

glyph_print:
	lda glyph_unicode_point
	cmp #$0d
	bne gp1
	lda glyph_unicode_point+1
	cmp #$00
	bne gp1
	
	; Found carriage return
	jmp unicode_newline
gp1:
	; XXX Add other non-printable glyphs (eg colour changes) here

	; Printable glyph

	; Get details about glyph
	jsr glyph_lookup

	; work out how wide the line would be with this glyph added
	lda glyph_width
	clc
	adc screen_line_pixels
	sta temp_word
	lda glyph_width+1
	adc screen_line_pixels+1
	cmp screen_line_pixels_width+1
	bcc glyph_fits
	beq glyph_might_fit
glyph_doesnt_fit:
	; start a new line if the glyph won't fit on the current line
	jsr unicode_newline
	bra glyph_fits
glyph_might_fit:
	lda temp_word
	cmp screen_line_pixels_width
	bcs glyph_doesnt_fit
glyph_fits:
	; Glyph fits, so stamp it
glyph_stamp:
	; Draw a glyph into the screen & colour RAM buffers
	
	; The screen line is screen_line_height tiles high.
	; screen_line_underhang_height of those tiles are below the baseline.
	; So the highest numbered row is:
	;   screen_line_height-1-screen_line_underhang_height

	; The glyph is glyph_tiles_high+glyph_tiles_underhang tiles high.
	; glyph_tiles_underhang are below the baseline.
	; So the highest numbered row is:
	;   glyph_tiles_high-1

	; For efficiency we wish to go through the glyph tile map and convert the 
	; glyph tile row number into the screen tile row number, and then decide
	; whether to stamp that row or not.

	; Work out where in the screen line the top line of the glyph corresponds
	lda glyph_tiles_high
	clc
	adc screen_line_underhang_height
	sta $57

	; work out number of rows that the glyph provides
	lda glyph_tiles_high
	clc
	adc glyph_tiles_underhang
	sta $58
	
	; get pointer to tile list
	lda glyph_tile_list_address
	sta $59
	lda glyph_tile_list_address+1
	sta $5a
	ldy #$00

	; and to colour RAM buffer
	lda #<colour_ram_buffer
	sta $5d
	lda #>colour_ram_buffer
	sta $5e

glyph_stamp_consider_row:
	lda $58
	beq stamping_done
	lda $57
	cmp screen_line_height
	bcs glyph_stamp_done_row ; don't draw rows above the top of the line
	bne stamping_done    ; stop if we go below the bottom of the line

	; we need to stamp this row 

	; get pointer to correct line of screen buffer in $5b/$5c
	lda screen_ram_buffer
	sta $5b
	lda screen_ram_buffer+1
	clc
	adc screen_line_height
	clc
	sbc $57
	sta $5c
	ldz screen_line_bytes

glyph_stamp_tile:
	; Now for each column of the row, stamp the appropriate tile
	ldx #$00
	cpx glyph_tiles_wide
	beq stamping_done
	
	; stamp column of glyph
	lda ($59),y
	clc
	adc font_tile_base
	sta ($5b),z
	lda glyph_colour
	sta ($5d),z
	iny
	inz
	lda ($59),y
	adc font_tile_base+1
	sta ($5b),z
	lda #$00
	sta ($5d),z
	iny
	inz
	
	inx
	bra glyph_stamp_tile

	; apply horizontal trim to last tile drawn
	; bits 2 and 1 are in upper byte of screen RAM:
	lda glyph_horizontal_trim
	asl
	asl
	asl
	asl
	asl
	and #$c0
	sta temp
	dez
	lda ($5b),z
	ora temp
	sta ($5b),z
	; bit 0 is in upper byte of colour RAM:
	lda glyph_horizontal_trim
	asl
	and #$02
	sta temp
	lda ($5d),z
	ora temp
	sta ($5d),z

glyph_stamp_done_row:
	dec $58
	bra glyph_stamp_consider_row


stamping_done:
	ldz #$00

	; XXX adjust bytes and pixels consumed

	rts

unicode_newline:
	; Clear unicode line status

	; Render the current line
	; (this will add the $FFFF EOL marker)
	jsr unicode_apply_line

	; Advance the screen RAM pointer to take account of the line
	lda screen_ram_applied_pointer
	sta screen_ram_pointer
	lda screen_ram_applied_pointer+1
	sta screen_ram_pointer+1

unl1:
	; reset horizontal position
	lda #$00
	sta screen_line_pixels
	sta screen_line_pixels+1
	sta screen_line_bytes

	rts

unicode_apply_line:
	; Take the contents of the screen RAM buffer and colour RAM buffer and
	; apply (draw) it onto the screen

	; get pointer to colour RAM buffer
	lda #<colour_ram_buffer
	sta $57
	lda #>colour_ram_buffer
	sta $58

	ldy #$00
ual_row:
	; For this screen row, get the address of the screen ram buffer
	lda #<screen_ram_buffer
	sta $59
	tya
	clc
	adc #>screen_ram_buffer
	sta $5a

	; and also of the screen RAM where we need to write
	lda screen_ram_base
	clc
	adc screen_ram_pointer
	sta $5b
	lda screen_ram_base+1
	adc screen_ram_pointer+1
	sta $5c
	
	; and also the colour RAM where we need to write
	; XXX - this only works for first KB of colour RAM - should use DMA
	; to write colour RAM (and in fact to apply all the data)
	lda #<$D800
	clc
	adc screen_ram_pointer
	sta $5d
	lda #>$D800
	adc screen_ram_pointer+1
	sta $5e

	; copy bytes
	ldz #$00
ual_1:	lda ($57),z
	sta ($59),z
	lda ($5b),z
	sta ($5d),z    ; XXX only works for first 1KB of colour RAM - should use DMA
	inz
	cpz screen_line_bytes
	bne ual_1
	; now append $FFFF to screen RAM and dummy bytes to colour RAM
	lda #$FF
	sta ($59),z
	sta ($5D),z
	inz
	sta ($59),z
	sta ($5D),z
	inz

	; advance screen RAM pointer
	tza
	clc
	adc screen_ram_pointer
	sta screen_ram_pointer
	lda screen_ram_pointer+1
	adc #$00
	sta screen_ram_pointer+1
	
	; clear Z so we don't upset and 6502 code
	ldz #$00

	; check for next row
	iny
	cpy screen_line_height
	bne ual_row

	rts

; scratch space
temp_word: .word 0
temp:	   .byte 0

; number of unicode points in font
font_glyphs:
	.word 0

font_tile_base:
	.word 0

; current glyph being drawn
glyph_unicode_point:
	.word 0
glyph_address:
	.word $0000
glyph_tiles_high:
	.byte 0
glyph_tiles_underhang:
	.byte 0
glyph_tiles_wide:
	.byte 0
glyph_horizontal_trim:
	.byte 0
; width of glyph in pixels
glyph_width:
	.word 0
; address of glyph tile list
glyph_tile_list_address:
	.word 0

glyph_colour:
	.byte 1

; Base number of glyph tiles
; Tiles are at fontheader+something, so base number is $4000/64 = $100
; this number gets added to the tile numbers extracted from the font
; to compute the VIC-IV tile number that points to the data.
glyph_tile_base:
	.word $0000,$0000

; Where screen RAM starts
screen_ram_base:
	.word $3000
; Where we are relative to screen RAM for start of line
screen_ram_pointer:
	.word $0000
; Where we are relative to screen RAM after rendering the current line
screen_ram_applied_pointer:
	.word $0000
; width of screen lines in pixels
screen_line_pixels_width:
	.word 960
; number of pixels used on current line
screen_line_pixels:
	.word $0000
; number of bytes used to encode current screen line.
; when end of line is reached, this is used to eliminate the excess characters.
screen_line_bytes:
	.byte 0
; height of current line in 8x8 tiles (including underhang)
screen_line_height:
	.byte 3
; number of those 8x8 tiles that are for underhang
screen_line_underhang_height:
	.byte 1
; buffer for screen lines.  256 bytes per line in the line buffer for screen RAM
; and colour RAM each limits lines to 128 8x8 tiles per line.  This seems a
; reasonable memory/max line length trade-off.  The trickier trade-off is the
; maximum number of tiles high that a row can be.  This will need to be reworked
; later, but for now, we will allow a line to be 8 tiles high. 8x256 = 2K.
; colour RAM only needs one row of buffer, since the colour information will be
; duplicated on each row of tiles.
screen_ram_buffer:
	.advance screen_ram_buffer+$800
colour_ram_buffer:
	.advance colour_ram_buffer+$100
	

; Keep $3000 - $3FFF for screen RAM
	.checkpc $3000
	.advance $3000

; 

; Include proportional font at $4000 (the file has 2 byte address header, so
; start at $3FFE
	.checkpc $3ffe
	.advance $3ffe
	.alias fontheader $4000

	.incbin "dejavus.f65"

	.scend

	.outfile "textmodetest.prg"