	.outfile "bitmap800x480.prg"

	 .word $0801
	 .org $0801

	 .scope
	 .word _next, 10                       ; Next line and current line number
	 .byte $97, "2,0:", $9e, " 2014", $AA, "65",0      ; POKE 2,0 : SYS 2014+65
_next:	 .word 0
    
	 .checkpc 2079
	 .advance 2079

	 sei

	 lda #$47
	 sta $d02f
	 lda #$53
	 sta $d02f
	 lda #$41
	 sta $0

	 jsr $e544

	 lda #<intromsg
	 ldy #>intromsg
	 jsr $ab1e


	 sei

	 jsr i2c_busscan

;	jsr test_touch2
	jsr test_touchscreen
	
	rts

i2c_busscan:
	; Start on bus 0, address 0
	 LDA #0
	 sta $d6d0
	 sta $d6d2

try:
	
	 ; reset I2C bus
	 lda #$08
	 sta $d6d1
	 lda #$09
	 sta $d6d1

l6:     
	 lda $d6d1
	 and #$c7
	 cmp #$01
	 bne l6

	 ; wait for busy to assert
	 LDA #$f
	 sta $d6d1
l1:     
	 lda $d6d1
	 and #$40
	 beq l1

	 ; make sure error flag clears
l2:     
         lda $d6d1
	 tax
	 and #$80
	 bne l2

	 ; wait for busy to clear
l7:     
	 lda $d6d1
	 and #$40
	 bne l7

	 ; check if succeeded or not
	 lda $d6d1
	 bpl gotit

resume:
	 lda $d6d2
	 clc
	 adc #$02
	 sta $d6d2
	 sta $0427
l3:     
	 cmp $d6d2
;	 bne l3
	 cmp #$00
	 bne try

notfound:
	; no devices found on this bus, so try next bus.
	; so far, we have only bus 0 and bus 1
	inc $d6d0
	lda $d6d0
	sta $0427
	cmp #1   ; only check bus 0, now that touch screen bus is wrapped     
	bne try

	lda #<donemsg
	ldy #>donemsg
	jsr $ab1e
	rts

gotit:
	phx
	phy
	; found an I2C device -- so report it.
	lda #<msg1
	ldy #>msg1
	jsr $ab1e
	lda #0
	ldx $d6d0
	jsr $bdcd
	lda #<msg2
	ldy #>msg2
	jsr $ab1e
	lda #0
	ldx $d6d2
	jsr $bdcd
	lda #<msg3
	ldy #>msg3
	jsr $ab1e
	ply
	plx

	; Attempt to identify the I2C device.

	jmp resume

intromsg:   .byte "SCANNING I2C BUSSES..",13,0
donemsg:    .byte "DONE.",13,0

msg1:	.byte "  FOUND BUS ",0
msg2:	.byte ", ADDRESS ",0
msg3:   .byte ".",13,0

touchmsg:
	.byte "TOUCH SCREEN TO TEST.",13,0

test_touch2:
	ldx #$00
tt2:	stx $d6bf
	lda $d6bf
	sta $0400,x
	inx
	jmp tt2



test_touchscreen:

	lda #<touchmsg
	ldy #>touchmsg	
	jsr $ab1e

	; On the lab unit the PWM modulation for the backlight is fed from
	; the MSB of blue, because we have run out of GPIOs on the FPGA board,
	; and it uses too much current combined with the FPGA if we have it set to
	; full-time on (tied to VCC).
	; so we need a display with enough blue to be visible, but not so much blue
	; that we cause voltage drops, which cause nasty white bars on the LCD.
	LDA #$0
	sta $d021
	lda #$6
	sta $d020

	; borders set to LCD size, so we can see full range of movement

	 ; The order below is a bit important.

	 ; Enable sprite H640 mode
 	 LDA	 $D054
	 ORA	 #$10
	 STA	 $D054

	 ; 1. Set horizontal border width
	 LDA #$00
	 STA $D05C
	 STA $D05D
	 lda #$1b
	 sta $d011

	 ; Make vertical borders a bit smaller
	 ; (600 - 480)/2 = 60 top and 60 bottom
	 ; then add fudge factor of 14 rasters
	 LDA 	#<73
	 STA	$D048 ; top border ends here
	 LDA	#>73
	 STA 	$D049 ; top border ends here
	 LDA	#<554
	 STA	$D04A
	 LDA 	#>554
	 STA	$D04B

	; two sprites for touch points
	lda #$03
	sta $d015

	LDA #14
	sta 2040
	sta 2041
	ldx #62
	lda #$00
sl1:	sta $0380,x
	dex
	bpl sl1
	; Draw little square sprite
	; (need $ff for 4x320H pixels, as we put sprite in H640 mode)
	lda #$ff
	sta $0380
	sta $0383
	sta $0386
	sta $0389

loop:
	ldy #0
	lda #<regs
	sta $fb
	lda #>regs
	sta $fc
	ldx #15
rnr:

	; Read raw I2C bytes
	; Touch panel is now using hardware accelerated I2C interface, so just
	; ask and read out the bytes. No need to use the old i2c_read_registers routine.

	ldy #$00
tt2b:	sty $d6bf
	lda $d6bf
	sta ($fb),y
	iny
	cpy #$10
	bne tt2b

	; dump registers to screen
;	ldy #0
;pl:	lda ($fb),y
;	sta $0478,y
;	iny
;	cpy #16
;	bne pl

	; reg 1 = gesture ID (seems to always be zero. maybe needs to be configured to be enabled)
	; reg 2 = number of current touch points
	; reg 3-8 = touch point 1
	; reg 9-14 = touch point 2

	lda #$00
	sta $d015

	ldy #0
ll99:	lda ($fb),y
	sta $04f0,y
	iny
	cpy #16
	bne ll99

	; Was there at least one touch event?
	Ldy #2
	lda ($fb),y
	beq loop

	lda #1
	tsb $d015

	ldy #3

	iny
	iny
	lda ($fb),y
	sta $0400
	dey
	dey
	and #$f0
	cmp #$f0
	beq n1
	lsr
	lsr
	lsr
	and #2
	tax

	jsr parse_touch
n1:
	; Are there two touch events?
	Ldy #2
	lda ($fb),y
	cmp #1
	beq loop

	lda #2
	tsb $d015

	ldy #9

	iny
	iny
	lda ($fb),y
	sta $0401
	dey
	dey
	and #$f0
	cmp #$f0
	beq n2
	lsr
	lsr
	lsr
	and #2
	tax


	jsr parse_touch
n2:

	jmp loop

	rts

parse_touch:
	; For each touch point:
	; byte 0.7-6 = 00=down, 01=liftup, 10=press down start, 11=up
	; byte 0.3-0 = MSB of Y position
	; byte 1 = LSB of Y position
	; byte 2.7-4 = touch id ($F = invalid)
	; byte 2.3-0 = MSB of X position
	; byte 3 = LSB of X position (not used?)
	; byte 4 = pressure of touch (not used?)

	; Show touch up/down status
;	lda ($fb),y
;	and #$c0
;	sta $0400,x

	; get y position (use upper 8 bits only for now)
	lda ($fb),y
	and #$f
	ror
	ror
	and #$80
	sta $fe

	iny
	lda ($fb),y
	lsr
	ora $fe
	; Vertically shift down the display a bit
	clc
	adc #26
	sta $d001,x

	; show touch ID
	; 0 or 1, or $F if the touch event is uninitialised and invalid
;	lda ($fb),y
;	and #$f0
;	lsr
;	lsr
;	lsr
;	lsr
;	sta $0428,x

	; get X position (upper 8 bits only)
	iny
	lda ($fb),y  ; get MSB bits ready
	and #$0f
	sta $fe
	; now subtract low bytes
	iny
	lda #<800
	sec
	sbc ($fb),y
	sta $fd
	dey
	lda #>800
	sbc $fe
	sta $fe
	iny

	; $FD/$FE now contains 0-799 X position, in correct direction.

	; Adjust for horizontal fudge factor
	lda $fd
	sec
	sbc #32
	sta $fd
	lda $fe
	sbc #0
	sta $fe

	; We are running sprites in H640 mode, so we can use values as-is
	lda $fd
	sta $d000,x
	cpx #$00
	bne sprite2

sprite0:
	; set super MSB	
	lda #$01
	trb $d05f
	lda $fe
	lsr
	and #$01
	tsb $d05f
	; set normal sprite X MSB
	lda #$01
	trb $d010	
	lda $fe
	and #$01
	tsb $d010

	rts

sprite2:
	; set super MSB	
	lda #$02
	trb $d05f
	lda $fe
	and #$02
	tsb $d05f
	; set normal sprite X MSB
	lda #$02
	trb $d010	
	lda $fe
	and #$01
	asl
	tsb $d010

	rts	

i2c_read_registers:
	; To read a register, we have to start by writing the address
	; of the register, and then once that is done, ask to read.
	; what we read back, is the content of the register.

	; XXX - For now we have some bugs, so always read from register 0
	; consecutively.

	; start by writing the register we want to read
	sty $d6d3
	; reset bus and lodge request (leaving touch panel enabled)
	lda #$08
	sta $d6d1
	lda #$09
	sta $d6d1

	; Write to set register number we want to read
	lda #$0b
	sta $d6d1

	; Wait for busy to set
rr1:	
	lda $d6d1
	and #$40
	beq rr1

	; Wait for busy to clear
rr2:    
	lda $d6d1
	and #$40
	bne rr2

rloop:
	; Then read
	lda #$0f
	sta $d6d1

	; Wait for busy to set
rr1c:	
	lda $d6d1
	and #$40
	beq rr1c


	; (as the continuation may cause BUSY to clear temporarily,
	; make sure it stays clear.  With a continuation, the busy
	; flag only clears for one 50MHz clock tick).
rr3:   
	lda $d6d1
	bmi rerror
	cmp #5
	bne rr3
rr3b:  
	lda $d6d1
	bmi rerror
	cmp #5
	bne rr3b

	lda $d6d4
	sta ($fb),y
	iny
	dex
	bne rloop
rerror:

	rts

regs:
	.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

	.scend