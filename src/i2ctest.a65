	.outfile "bitmap800x480.prg"

	 .word $0801
	 .org $0801

	 .scope
	 .word _next, 10                       ; Next line and current line number
	 .byte $97, "2,0:", $9e, " 2014", $AA, "65",0      ; POKE 2,0 : SYS 2014+65
_next:	 .word 0
    
	 .checkpc 2079
	 .advance 2079

	 sei

	 lda #$47
	 sta $d02f
	 lda #$53
	 sta $d02f
	 lda #$41
	 sta $0

	 jsr $e544

	 lda #<intromsg
	 ldy #>intromsg
	 jsr $ab1e

	 ; Select I2C bus 1, and set first address to probe
	 LDA #1
	 sta $d6d0

	; Start on bus 0, address 0
	 LDA #0
	 sta $d6d0
	 sta $d6d2

try:
	sei
	
	lda $d6d0
	sta $0426
	lda $d6d2
	sta $0427

	 ; reset I2C bus
	 lda #$00
	 sta $d6d1
	 lda #$01
	 sta $d6d1

l6:      inc $041f
	 lda $d6d1
	 cmp #$01
	 bne l6

	 ; wait for busy to assert
	 LDA #$7
	 sta $d6d1
l1:      inc $0420
	 lda $d6d1
	 and #$40
	 beq l1

	 ; make sure error flag clears
l2:      inc $0421
         lda $d6d1
	 tax
	 and #$80
	 bne l2

	 ; wait for busy to clear
l7:      inc $0422
	 lda $d6d1
	 and #$40
	 bne l7

	 ; check if succeeded or not
	 lda $d6d1
	 bpl gotit

resume:
	 lda $d6d2
	 clc
	 adc #$02
	 sta $d6d2
l3:      inc $0424
	 cmp $d6d2
;	 bne l3
	 cmp #$00
	 bne try

notfound:
	; no devices found on this bus, so try next bus.
	; so far, we have only bus 0 and bus 1
	inc $d6d0
	lda $d6d0
	cmp #2      
	bne try

	lda #<donemsg
	ldy #>donemsg
	jsr $ab1e
	cli

	jsr test_touchscreen
	
	rts

gotit:
	phx
	phy
	; found an I2C device -- so report it.
	lda #<msg1
	ldy #>msg1
	jsr $ab1e
	lda #0
	ldx $d6d0
	jsr $bdcd
	lda #<msg2
	ldy #>msg2
	jsr $ab1e
	lda #0
	ldx $d6d2
	jsr $bdcd
	lda #<msg3
	ldy #>msg3
	jsr $ab1e
	ply
	plx

	; Attempt to identify the I2C device.

	jmp resume

intromsg:   .byte "SCANNING I2C BUSSES..",13,0
donemsg:    .byte "DONE.",13,0

msg1:	.byte "  FOUND BUS ",0
msg2:	.byte ", ADDRESS ",0
msg3:   .byte ".",13,0

test_touchscreen:

	; On the lab unit the PWM modulation for the backlight is fed from
	; the MSB of blue, because we have run out of GPIOs on the FPGA board,
	; and it uses too much current combined with the FPGA if we have it set to
	; full-time on (tied to VCC).
	; so we need a display with enough blue to be visible, but not so much blue
	; that we cause voltage drops, which cause nasty white bars on the LCD.
	LDA #$0
	sta $d021
	lda #$6
	sta $d020

	; borders set to LCD size, so we can see full range of movement

	 ; The order below is a bit important.

	 ; Enable sprite H640 mode
 	 LDA	 $D054
	 ORA	 #$10
	 STA	 $D054

	 ; 1. Set horizontal border width
	 LDA #$00
	 STA $D05C
	 STA $D05D
	 lda #$1b
	 sta $d011

	 ; Make vertical borders a bit smaller
	 ; (600 - 480)/2 = 60 top and 60 bottom
	 ; then add fudge factor of 14 rasters
	 LDA 	#<73
	 STA	$D048 ; top border ends here
	 LDA	#>73
	 STA 	$D049 ; top border ends here
	 LDA	#<554
	 STA	$D04A
	 LDA 	#>554
	 STA	$D04B

	; two sprites for touch points
	lda #$03
	sta $d015

	LDA #14
	sta 2040
	sta 2041
	ldx #62
	lda #$00
sl1:	sta $0380,x
	dex
	bpl sl1
	lda #$f0
	sta $0380
	sta $0383
	sta $0386
	sta $0389

	; Select default touch screen bus and address
	LDA #1
	sta $d6d0
	lda #112
	sta $d6d2

;	lda #0
;	sta $d6d0
;	lda #150
;	sta $d6d2

loop:
;	jsr $ffe4
;	beq loop
;	inc $d020


	ldy #0
	lda #<regs
	sta $fb
	lda #>regs
	sta $fc
	ldx #15
rnr:	jsr i2c_read_registers

	; dump registers to screen
	lda #0
pl:	lda ($fb),y
	sta $0478,y
	iny
	cpy #16
	bne pl

	; reg 1 = gesture ID (seems to always be zero. maybe needs to be configured to be enabled)
	; reg 2 = number of current touch points
	; reg 3-8 = touch point 1
	; reg 9-14 = touch point 2

	lda #$00
	sta $d015

	; Was there at least one touch event?
	Ldy #2
	lda ($fb),y
	sta $0501
	beq loop

	lda #1
	tsb $d015

	ldy #3
	ldx #0
	jsr parse_touch

	; Are there two touch events?
	Ldy #2
	lda ($fb),y
	cmp #1
	beq loop

	lda #2
	tsb $d015

	ldy #9
	ldx #2
	jsr parse_touch


	jmp loop

	rts

parse_touch:
	; For each touch point:
	; byte 0.7-6 = 00=down, 01=liftup, 10=press down start, 11=up
	; byte 0.3-0 = MSB of Y position
	; byte 1 = LSB of Y position
	; byte 2.7-4 = touch id ($F = invalid)
	; byte 2.3-0 = MSB of X position
	; byte 3 = LSB of X position (not used?)
	; byte 4 = pressure of touch (not used?)

	; Show touch up/down status
	lda ($fb),y
	and #$c0
	sta $0400,x

	; get y position (use upper 8 bits only for now)
	lda ($fb),y
	and #$f
	ror
	ror
	and #$80
	sta $fe

	iny
	lda ($fb),y
	lsr
	ora $fe
	; Vertically shift down the display a bit
	clc
	adc #26
	sta $d001,x

	; get touch ID
	iny
	lda ($fb),y
	and #$f0
	lsr
	lsr
	lsr
	lsr
	sta $0428,x

	; get X position (upper 8 bits only)
	lda #>800
	iny
	sec
	sbc ($fb),y
	sta $fd
	dey
	lda #<800
	sbc ($fb),y
	sta $fe
	iny

	; $FD/$FE now contains 0-799 X position, in correct direction.
	; We are running sprites in H640 mode, so we can use values as-is
	lda $fd
	sta $d000,x
	cpx #$00
	bne sprite2

sprite0:
	lda $fe
	sta $0500

	; set super MSB
	lda $d05f
	and #$fe
	sta $d05f
	lda $fe
	lsr
	and #$01
	tsb $d05f
	; set normal sprite X MSB
	lda #$01
	trb $d010
	lda $fe
	and #$01
	tsb $fe
	rts

sprite2:

	rts	

i2c_read_registers:
	; To read a register, we have to start by writing the address
	; of the register, and then once that is done, ask to read.
	; what we read back, is the content of the register.

	; XXX - For now we have some bugs, so always read from register 0
	; consecutively.

	; start by writing the register we want to read
	sty $d6d3
	sty $0400
	; reset bus and lodge request
	lda #$00
	sta $d6d1
	lda #$01
	sta $d6d1

	; Write to set register number we want to read
	lda #$03
	sta $d6d1

	inc $0447

	; Wait for busy to set
rr1:	inc $0448
	lda $d6d1
	sta $0418
	and #$40
	beq rr1

	; Wait for busy to clear
rr2:    inc $0449
	lda $d6d1
	and #$40
	bne rr2

rloop:
	; Then read
	lda #$07
	sta $d6d1

	; Wait for busy to set
rr1c:	inc $0448
	lda $d6d1
	sta $0418
	and #$40
	beq rr1c


	; (as the continuation may cause BUSY to clear temporarily,
	; make sure it stays clear.  With a continuation, the busy
	; flag only clears for one 50MHz clock tick).
rr3:    inc $044a
	lda $d6d1
	bmi rerror
	cmp #5
	bne rr3
	sta $0419
rr3b:    inc $044a
	lda $d6d1
	bmi rerror
	cmp #5
	bne rr3b
	sta $0419

	lda $d6d4
	sta $04a0,y
	sta ($fb),y
	iny
	dex
	bne rloop
rerror:

	rts

regs:
	.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

	.scend