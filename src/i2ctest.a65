	.outfile "bitmap800x480.prg"

	 .word $0801
	 .org $0801

	 .scope
	 .word _next, 10                       ; Next line and current line number
	 .byte $97, "2,0:", $9e, " 2014", $AA, "65",0      ; POKE 2,0 : SYS 2014+65
_next:	 .word 0
    
	 .checkpc 2079
	 .advance 2079

	 sei

	 lda #$47
	 sta $d02f
	 lda #$53
	 sta $d02f
	 lda #$41
	 sta $0

	 jsr $e544

	 lda #<intromsg
	 ldy #>intromsg
	 jsr $ab1e

	 ; Select I2C bus 1, and set first address to probe
	 LDA #1
	 sta $d6d0

	; Start on bus 0, address 0
	 LDA #0
	 sta $d6d0
	 sta $d6d2

try:
	sei
	
	lda $d6d0
	sta $0426
	lda $d6d2
	sta $0427

	 ; reset I2C bus
	 lda #$00
	 sta $d6d1
	 lda #$01
	 sta $d6d1

l6:      inc $041f
	 lda $d6d1
	 cmp #$01
	 bne l6

	 ; wait for busy to assert
	 LDA #$7
	 sta $d6d1
l1:      inc $0420
	 lda $d6d1
	 and #$40
	 beq l1

	 ; make sure error flag clears
l2:      inc $0421
         lda $d6d1
	 tax
	 and #$80
	 bne l2

	 ; wait for busy to clear
l7:      inc $0422
	 lda $d6d1
	 and #$40
	 bne l7

	 ; check if succeeded or not
	 lda $d6d1
	 bpl gotit

resume:
	 lda $d6d2
	 clc
	 adc #$02
	 sta $d6d2
l3:      inc $0424
	 cmp $d6d2
;	 bne l3
	 cmp #$00
	 bne try

notfound:
	; no devices found on this bus, so try next bus.
	; so far, we have only bus 0 and bus 1
	inc $d6d0
	lda $d6d0
	cmp #2      
	bne try

	lda #<donemsg
	lda #>donemsg
	jsr $ab1e
	cli

	jsr test_touchscreen
	
	rts

gotit:
	phx
	phy
	; found an I2C device -- so report it.
	lda #<msg1
	ldy #>msg1
	jsr $ab1e
	lda #0
	ldx $d6d0
	jsr $bdcd
	lda #<msg2
	ldy #>msg2
	jsr $ab1e
	lda #0
	ldx $d6d2
	jsr $bdcd
	lda #<msg3
	ldy #>msg3
	jsr $ab1e
	ply
	plx

	; Attempt to identify the I2C device.

	jmp resume

intromsg:   .byte "SCANNING I2C BUSSES..",13,0
donemsg:    .byte "DONE.",13,0

msg1:	.byte "  FOUND BUS ",0
msg2:	.byte ", ADDRESS ",0
msg3:   .byte ".",13,0

test_touchscreen:
	; Select default touch screen bus and address
	LDA #1
	sta $d6d0
	lda #112
	sta $d6d2

loop:
	jsr $ffe4
	beq loop
	inc $d020


	ldy #0
rnr:	jsr i2c_read_register
	sta $0478,y
	iny
	cpy #39
;	bne rnr

	jmp loop

	rts

i2c_read_register:
	; To read a register, we have to start by writing the address
	; of the register, and then once that is done, ask to read.
	; what we read back, is the content of the register.

	 ; reset I2C bus
	 lda #$00
	 sta $d6d1
	 lda #$01
	 sta $d6d1


	; start by writing the register we want to read
	sty $d6d3
	lda #$05
	sta $d6d1

	inc $0447

	; Wait for busy to set
	ldx #$00	
rr1:	inc $0448
	lda $d6d1
	sta $0418
	and #$40
	beq rr1

	; While busy still set, issue read command, so that it follows
	; on as a continuation.
	lda #$07
	sta $d6d1

	; Wait for busy to clear
rr2:    inc $0449
	lda $d6d1
	and #$40
	bne rr2
	; (as the continuation may cause BUSY to clear temporarily,
	; make sure it stays clear.  With a continuation, the busy
	; flag only clears for one 50MHz clock tick).
rr3:    inc $044a
	lda $d6d1
	cmp #5
	bne rr3
	sta $0419

	lda $d6d4
	rts

	.scend