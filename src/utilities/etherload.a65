; Simple ethernet programme loader for C65GS.
; Reads and checks packets, and then runs code contained in the packets.
; This keeps the programme VERY small.
; Now supports ARP replies to make life easier.

      .org $8000
      .scope

programentrypoint:
	sei

	; C65GS io
	lda #$47
	sta $d02f
	lda #$53
	sta $D02f

	; Fast CPU
	lda #65
	sta 0

	; Set ethernet controller mode
	lda #$75  ; Enable promiscuous mode, multicast and broadcast RX, tx/rx phase = 1
	sta $d6e5

	; Clear all waiting frames
	; (this is because the trigger frame gets processed _immediately_ on its reception,
	;  even before the frame has finished being received).
purgequeue:
	jsr getnextframe
	lda $d6e1
	and #$20
	bne purgequeue	

	; Map ethernet registers at $6000 - $7FFF
	
	; Ethernet controller really lives $FFDE000 - $FFDEFFF, so select $FF megabyte section for MAP LO
	lda #$ff
	ldx #$0f
	; Also for keeping ourselves mapped in the upper half of RAM
	tay
	ldz #$0f
	map
	eom

	; now enable mapping of $DE000-$DFFFF at $6000
	; MAPs are offset based, so we need to subtract $6000 from the target address
	; $DE000 - $6000 = $D8000
	lda #$80
	ldx #$8d
	; Keep ourselves mapped in upper half of RAM
	ldy #$ff
	ldz #$17
	map
	eom

	; zeroize ip address
	ldx #$03
zeroip:
	lda #$00
	sta $80fc,x
	dex
	bpl zeroip


	; Ethernet memory mapped buffer access should now be visible from $6000 - $6FFF
	; read buffer will be at $6800 - $6FFF
	; length of frame is in $6800 / $6801 in little-endian byte order
	; so LDA $6800 ; LDX $6801 ; jsr $BDCD should print packet length to screen

	; make sure ethernet transceiver is on and not generating IRQs
	; (we will poll it).
	; also make sure that we acknowledge the last received packet so that the
	; ethernet controller knows it can receive.

loop:

	; eth buffer as basepage to save bytes accessing it
	; IMPORTANT: This means all memory access to base page addresses will actually
	; target the Ethernet buffer. Reading from it provides rx data (starting at offset
	; 2 since the first two bytes are the length of the frame). Writing to it writes
	; to the TX buffer (which does not have any offset, since it is not preceded by
	; a length field).
	lda #$68
	tab

nextpacket:

waitingforpacket:

	lda $d6e1
	and #$20
	beq waitingforpacket

	jsr getnextframe

; show length of ethernet frame

	; Got a packet.
	; check whether it is UDP port 4510
	; or whether it is an ARP request

	; Is it an ARP request?
	; Here we want to check that $680E - $6817 =
	; 08 06 00 01 08 00 06 04 00 01
	;

	ldx #9
arpdloop:
	lda arptemplate,x
	lda $0e,x
	dex
	bpl arpdloop

	ldx #$09
arploop0:
	lda $0e,x
	cmp arptemplate,x
	bne notarp
	dex
	bpl arploop0

	; yes, we have ARP
	; check that IP address asked for is the same as ours
	;
	ldx #$03
arploop5:
	lda $80fc,x
	cmp $28,x
	bne notarp

	; ok, so we have an ARP request.
	; now we need to build the ARP reply and send it.
	; We should copy the sender's 

	; set output packet size
	; 6+6+2 bytes ethernet header + 28 bytes of ARP reply = 42
	lda #<42
	sta $d6e2
	lda #>42
	sta $d6e3

	; copy fixed ARP fields (we will overwrite some later)
	; (note that TX buffer lacks 2 byte RX buffer header)
	ldx #$14
arploop1:
	lda $02,x
	sta $00,x
	dex
	bpl arploop1
	; Copy ethernet source to ethernet destination in TX buffer
	; Set our mac address in ethernet source address field in TX buffer
	ldx #$05
arploop2:
	lda $08,x    ; requestors mac from RX ethernet header
	sta $00,x    ; requestors mac into TX ethernet header
	lda $d6e9,x
	sta $06,x    ; our mac in ethernet header
	sta $16,x    ; our mac in ARP payload
	dex
	bpl arploop2
	; set packet as ARP reply
	lda #$02     ; $02 = reply, $01 = request
	sta $15

	ldx #$03
	; copy requested IP address into reply IP address field
arploop3:
	lda $28,x
	sta $1c,x
	dex
	bpl arploop3
	; copy requestors MAC+IP into target MAC+IP fields
	ldx #9
arploop4:
	lda $18,x
	sta $20,x
	dex
	bpl arploop4
	
	; packet should now all be ready - hit TX button
	lda #$01
	sta $d6e4	

	; Fall through to rest of packet parser (even though it won't pass
	; these tests -- it just saves a few bytes of code).

notarp:
	; is it IPv4?
	;

	lda $10
	cmp #$45
	bne nextpacket

	; is it UDP?
	;
	lda $19
	cmp #$11
	bne nextpacket

	; UDP port #4510
	;
	lda $26
	cmp #>4510
	bne nextpacket
	lda $27
	cmp #<4510
	bne nextpacket

	; packet body begins at $682C.
	; if it begins with $A9 = LDA immediate, then jsr to the packet body.
	; packet body can do whatever is required to load data, keeping this
	; programme very simple.
	;
	lda $2c
	cmp #$a9
	bne loop

	; packet does begin with A9, so JSR there
	; The code in the packet will end with an RTS, bringing us back here,
	; allowing our loop to continue.
	lda #$01
	sta $d020
	lda #$00
	tab
	jsr $682C
	lda #$00
	sta $d020

	jmp loop

getnextframe:
	; we have detected that we have recieved a packet
	; so, clear eth RX signal, and leave ethernet tranceiver on
	; and make last used RX buffer visible
	lda #$01
	sta $d6e1
	lda #$03
	sta $d6e1
	rts

arptemplate:
	.byte $08,$06,$00,$01,$08,$00,$06,$04,$00,$01

	.checkpc $80FC
	.scend

	.outfile "sdcard-files/ETHLOAD.M65"
