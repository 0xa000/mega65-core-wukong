	.outfile "thumbnail.prg"

	 .word $0801
	 .org $0801

	 .scope
	 .word _next, 10                       ; Next line and current line number
	 .byte $97, "2,0:", $9e, " 2014", $AA, "65",0      ; POKE 2,0 : SYS 2014+65
_next:	 .word 0

iter1:	 .byte 0

	 .checkpc 2079
	 .advance 2079

	 ; C65GS IO
	 lda #$47
	 sta $d02f
	 lda #$53
	 sta $d02f

	 sei

	 jsr set_palette
	 jsr redraw_fullcolour_area

	 ; raster interrupt to toggle normal/full-colour mode
	 
	 lda #$00
	 sta $d012
	 lda #$1b
	 sta $d011
	 lda #$81
	 sta $d01a
	 lda #$7f
	 sta $dc0d
	 sta $dd0d

	 lda #<irq_00
	 sta $0314
	 lda #>irq_00
	 sta $0315

	 cli
	 rts

irq_a0:
	 ; wait a bit to clear raster line
	 ldx #$00
l5:	 nop
	 nop	 
	 dex
	 bne l5

	 ; enable full-colour mode
	 lda #$02
	 sta $d054

	 lda #$00
	 sta $d012
	 lda #$1b
	 sta $d011

	 ; switch to irq split at top of screen
	 lda #<irq_00
	 sta $0314
	 lda #>irq_00
	 sta $0315

	 dec $d019
	 jmp $ea81

irq_00:
	 ; disable full-colour mode
	 lda #$00
	 sta $d054

	 lda #$c2
	 sta $d012
	 lda #$1b
	 sta $d011

	 jsr redraw_fullcolour_area

	 ; copy thumbnail data into our full-colour display
	 ; read $D630 to reset read pointer
	 lda $d630
	 ; now read 4000 bytes out and store into the grid at $2000.
	 ; thumbnail data is written linearly, so every 8 pixels we need to add
	 ; 64-8 bytes, and at the end of every row, i.e., every 80 bytes, we need
	 ; to subtract 9*64 = $240.
	 lda #<$2000
	 sta tw+1
	 lda #>$2000
	 sta tw+2
	 lda #<4000
	 sta count
	 lda #>4000
	 sta count+1
	 ldx #8
	 ldy #80
	 ldz #$08
twloop:
	; get thumbnail byte
	lda $d631
tw:     ; store it in place
	sta $2000
	; advance write address by 1
	inc tw+1
	bne tw2
	inc tw+2
tw2:	; see if we need to advance write address by 64-8 = 56
	dex
	bne tw3
	ldx #8
	lda tw+1
	clc
	adc #56
	sta tw+1
	lda tw+2
	adc #$00
	sta tw+2
tw3:    ; see if we need to retreat write address by (10*64-8)
	; we do this 7 out of 8 rows
	dey
	bne tw4
	ldy #80
	dez
	beq tw5
	lda tw+1
	sec
	sbc #<632
	sta tw+1
	lda tw+2
	sbc #>632
	sta tw+2
	jmp tw4	
tw5:
	; every 8th row, just reverse by 8 bytes.
	ldz #8
	lda tw+1
	sec
	sbc #<8
	sta tw+1
	lda tw+2
	sbc #>8
	sta tw+2
	
tw4:
	dec count
	bne twloop
	dec count+1
	bne twloop


	ldz #$00

	 ; switch to irq split at bottom
	 lda #<irq_a0
	 sta $0314
	 lda #>irq_a0
	 sta $0315

	 ; do keyboard input
	 dec $d019
	 jmp $ea31
	 
	 ; number of bytes to copy from thumbnail
count:	 .byte $00,$00

redraw_fullcolour_area:
	 ; arrange tiles in lower part of the screen to display the thumbnail.
	 ; char $80-$FF are @ $2000-$3FFF.
	 ; start by filling the region with $FF, and clearing that tile.
	 lda #$ff
	 ldy #$00
l2:	 sta $06d0,y
	 sta $0700,y
	 iny
	 bne l2

	 ; now clear glyph $FF
	 ldy #$3f
	 lda #$00
l3:	 sta $3fc0,y
	 dey
	 bpl l3

	 ; now draw the 80x50 space for the thumbnail.
	 ; this will be 10x7 glyphs
	 lda #<$06ee
	 sta l4+1
	 lda #>$06ee
	 sta l4+2
	 lda #$80
	 ldx #$00
	 ldy #$00
l4:	 sta $06ee,x
	 inc
	 inx
	 cpx #$0a
	 bne l4
	 pha
	 clc
	 lda l4+1
	 adc #$28
	 sta l4+1
	 lda #$00
	 adc l4+2
	 sta l4+2
	 pla
	 ldx #$00
	 iny
	 cpy #$07
	 bne l4
	 rts

set_palette:
	ldy #$10
	
pl:	tya
	lsr
	lsr
	lsr
	lsr
	ora #$00
	sta $d100,y
	tya
	lsr
	and #$0f
	ora #$00
	sta $d200,y
	tya
	asl
	asl
	and #$0f
	ora #$00
	sta $d300,y
	iny
	bne pl
	rts

	.scend